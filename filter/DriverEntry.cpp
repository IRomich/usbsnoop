<<<<<<< DriverEntry.cpp
// Main program for UsbSnoop driver
// Generated by Walt Oney's driver wizard

#include "stddcls.h"
#include "driver.h"
#include "usbioctl.h"

NTSTATUS AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT pdo);
VOID DriverUnload(IN PDRIVER_OBJECT fido);
NTSTATUS DispatchAny(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchPower(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchPnp(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchWmi(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchInternalIOCTL(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS MyDispatchInternalIOCTL(IN PDEVICE_OBJECT fido, IN PIRP Irp);
void DumpURB(PURB pUrb, BOOLEAN bReturnedFromHCD);

BOOLEAN win98 = FALSE;
UNICODE_STRING servkey;
HANDLE fileHandle = (HANDLE)NULL;
KSEMAPHORE DataToBeRead;
//PWORK_QUEUE_ITEM BottomHalf;
HANDLE ThreadHandle;
BOOLEAN Loging;

struct RollingBuffer
{
	int StartPos;
	int EndPos;
	char Buffer[BUFFER_SIZE];
};


struct RollingBuffer LogBuffer;

// functions to handle conversion from PipeHandle to endpint number

struct ENDPOINT_INFO 
{
    USBD_PIPE_HANDLE PipeHandle;
	unsigned char    Endpoint;
};

struct ENDPOINT_INFO TabEndpointInfo[10] =
{
	{ NULL, 0 },
};

bool GetEndpointInfo(USBD_PIPE_HANDLE inPipeHandle, unsigned char * outEndpoint)
{
	for (int i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle != NULL 
			&& TabEndpointInfo[i].PipeHandle == inPipeHandle)
		{
			*outEndpoint = TabEndpointInfo[i].Endpoint;
			return true;
		}
	}

	return false;
}

//		Jean-Séabstien Valette
//
//		FillRollingBuffer
//
//		13 09 2001
//
//		Copy a string to the rolling Buffer

void inline FillRollingBuffer(char *s)
{
	int bufflen;

	//bufflen = strlen(s);
	bufflen = 30;

	if(LogBuffer.EndPos >= LogBuffer.StartPos)
		if(LogBuffer.EndPos + bufflen < BUFFER_SIZE)
		{
			KdPrint(("Fillrollingbuffer 1\n"));
			memcpy(LogBuffer.Buffer + LogBuffer.EndPos,
				s,bufflen);
			LogBuffer.EndPos +=  bufflen;
		}
		else
		{
			KdPrint(("Fillrollingbuffer 2\n"));
			memcpy(LogBuffer.Buffer + LogBuffer.EndPos,
				s,BUFFER_SIZE - LogBuffer.EndPos);
			memcpy(LogBuffer.Buffer, s + BUFFER_SIZE - LogBuffer.EndPos,
				bufflen - (BUFFER_SIZE - LogBuffer.EndPos));
			LogBuffer.EndPos += bufflen - BUFFER_SIZE;

		}
	else
		if(LogBuffer.EndPos + bufflen < LogBuffer.StartPos)
		{
			KdPrint(("\n\nFillrollingbuffer 3\n"));
			memcpy(LogBuffer.Buffer + LogBuffer.EndPos, s, bufflen);
			LogBuffer.EndPos +=  bufflen;
		}
		else
		{
			KdPrint(("Fillrollingbuffer 4\n"));
			KdPrint(("usbsnoop : Buffer Overrun \nusbsnoop: Data lost : %s\n",s));
			KdPrint(("usbsnoop : StartPos %d, Endpos : %d\n", 
				LogBuffer.StartPos, LogBuffer.EndPos));

		}
		KdPrint(("usbsnoop: Start %d, Stop %d\n",
			LogBuffer.StartPos, LogBuffer.EndPos));


}

//		Jean-Sébastien Valette
//
//		Write To LogFile
//
//		26 08 2001
//
//		09 09 2001 change to be a thread
//

VOID LogToFile(PVOID Parameter)
{
	char *test = "Test\n";
	NTSTATUS status;
	IO_STATUS_BLOCK ioStatusBlock;
	OBJECT_ATTRIBUTES objectAttributes;
	UNICODE_STRING unicodeObjectName;
	ANSI_STRING ansiObjectName;
	LARGE_INTEGER Timeout;
	int endpos;
	LARGE_INTEGER offset;

	char *version="UsbSnoop compiled on " __DATE__ " " __TIME__ "\n";

	
	//	Jean-Sébastien Valette 08 09 2001
	//
	//	try to open a log File

	RtlInitAnsiString(&ansiObjectName,"\\SystemRoot\\snoopy.log");
 	status = RtlAnsiStringToUnicodeString(&unicodeObjectName,&ansiObjectName,TRUE);
	if (status != STATUS_SUCCESS)
 		KdPrint(("RtlAnsiStringToUnicodeString failed, status = 0x%xx\n",status));
	InitializeObjectAttributes(&objectAttributes,&unicodeObjectName,0,NULL,NULL);


 
 	//status = ZwCreateFile(&fileHandle,FILE_WRITE_DATA|SYNCHRONIZE ,
	// 	&objectAttributes,&ioStatusBlock,NULL,FILE_ATTRIBUTE_NORMAL,FILE_SHARE_READ,
	//FILE_OPEN_IF,FILE_SYNCHRONOUS_IO_NONALERT,NULL,0);
	status = ZwCreateFile(&fileHandle,GENERIC_WRITE,
	 	&objectAttributes,&ioStatusBlock,NULL,FILE_ATTRIBUTE_NORMAL,FILE_SHARE_READ,
	FILE_OPEN_IF,FILE_SYNCHRONOUS_IO_NONALERT,NULL,0);
 	if (status != STATUS_SUCCESS)
 		KdPrint(("ZwCreateFile failed, status = 0x%x\n",status));
	else
		KdPrint(("\n\nusbsnoop: File Opened\nusbsnoop: fileHandle = %x\n",
			fileHandle));

	status = ZwWriteFile(fileHandle,NULL,NULL,NULL,&ioStatusBlock,version,
				(unsigned long)strlen(version),NULL,NULL);
	if(status != STATUS_SUCCESS )
	{
		KdPrint(("Can't write into Logfile, status = %x\n",status));
		ZwClose(fileHandle);
	}
	Timeout.QuadPart = -1000000;
	Loging = TRUE;
	offset.QuadPart = strlen(version);
	while(Loging != FALSE)
	{
		status = KeWaitForSingleObject(&DataToBeRead,Executive, KernelMode,
			FALSE,&Timeout);
		if(status == STATUS_SUCCESS)
		{
			KdPrint(("usbsnoop: LogToFile AWAKE !\n"));
			endpos = LogBuffer.EndPos;
			if(LogBuffer.StartPos != endpos)
			{
				KdPrint(("usbsnoop: Start %d, Stop %d\n",
					LogBuffer.StartPos, endpos));
				KdPrint(("UsbSnoop: offset %Ld\n",offset.QuadPart));
				KdPrint(("UsbSnoop: string for file %.30s\n %Ld\n",
					&(LogBuffer.Buffer[LogBuffer.StartPos])));
				if( endpos > LogBuffer.StartPos)
				{
					status = ZwWriteFile(fileHandle,NULL,NULL,NULL,
						&ioStatusBlock, 
						&(LogBuffer.Buffer[LogBuffer.StartPos]), 
						endpos - LogBuffer.StartPos , &offset,NULL);
					if( status != STATUS_SUCCESS )
						KdPrint(("UsbSnoop : Can't WriteTofFile\nStatus %x",
								status));
					else
						offset.QuadPart += endpos - LogBuffer.StartPos;

				}
				else
				{	//	BUG IS HERE
					if(LogBuffer.StartPos != BUFFER_SIZE)
					{
						ZwWriteFile(fileHandle,NULL,NULL,NULL,
							&ioStatusBlock,
							&(LogBuffer.Buffer[LogBuffer.StartPos]),
							BUFFER_SIZE - LogBuffer.StartPos, &offset,
							NULL);
						if( status != STATUS_SUCCESS )
							KdPrint(("UsbSnoop : Can't WriteTofFile\nStatus %x",
									status));
						else
							offset.QuadPart += BUFFER_SIZE - LogBuffer.StartPos;
					}
					//END CODE PROBLEM
					ZwWriteFile(fileHandle,NULL,NULL,NULL,
						&ioStatusBlock,
						&(LogBuffer.Buffer[0]), endpos, &offset, NULL);
					if( status != STATUS_SUCCESS )
						KdPrint(("UsbSnoop : Can't WriteTofFile\nStatus %x",
								status));
					else
						offset.QuadPart += endpos;
				}
				LogBuffer.StartPos = endpos;
			}
		}
	}


	ZwClose(fileHandle);

	
	PsTerminateSystemThread(STATUS_SUCCESS);
	return;	
};




void AddEndpointInfo(USBD_PIPE_HANDLE inPipeHandle, unsigned char inEndpoint)
{
	int i;

	// search for an existing PipeHandle
	for (i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle != NULL 
			&& TabEndpointInfo[i].PipeHandle == inPipeHandle)
			return ; 
	}

	// search for a free slot 
	for (i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle == NULL)
		{
			TabEndpointInfo[i].PipeHandle = inPipeHandle;
			TabEndpointInfo[i].Endpoint = inEndpoint;
			return ;
		}
	}

	KdPrint(("AddEndpointInfo failed!\n"));
}



///////////////////////////////////////////////////////////////////////////////

void DumpStackLocation(PIO_STACK_LOCATION stack)
{
	if (stack == NULL)
		return ;

	KdPrint(("    MajorFunction=%d, MinorFunction=%d\n",
		stack->MajorFunction,stack->MinorFunction));
	KdPrint(("    DeviceObject=%p\n",stack->DeviceObject));
	KdPrint(("    CompletionRoutine=%p Context=%p\n",stack->CompletionRoutine,stack->Context));

}

void DumpIrp(PIRP Irp)
{
	KdPrint(("Dumping IRP %p\n",Irp));
	if (Irp==NULL)
		return ;

	KdPrint(("  Type=%d, Size=%d\n",Irp->Type,Irp->Size));
	KdPrint(("  StackCount=%d, CurrentLocation=%d\n",Irp->StackCount,Irp->CurrentLocation));
	for (CHAR i=0;i<Irp->StackCount;i++)
	{
		PIO_STACK_LOCATION stack = (PIO_STACK_LOCATION) (Irp+1) + i;
		KdPrint(("  [%d] MajorFunction=%d, MinorFunction=%d, DeviceObject=%p\n",
			i,stack->MajorFunction,stack->MinorFunction,stack->DeviceObject));
		KdPrint(("      Arg1=%p, Arg2=%p, Arg3=%p, Arg4=%p\n",
			stack->Parameters.Others.Argument1,stack->Parameters.Others.Argument2,
			stack->Parameters.Others.Argument3,stack->Parameters.Others.Argument4));
		KdPrint(("      CompletionRoutine=%p Context=%p\n",
			stack->CompletionRoutine,stack->Context));
	}
}

void DumpDriverObject(PDRIVER_OBJECT p)
{
	KdPrint(("UsbSnoop - DumpDriverObject : p = %p\n",p));
	KdPrint(("  Type = %d\n",p->Type));
	KdPrint(("  Size = %d\n",p->Size));
	KdPrint(("  DeviceObject = %p\n",p->DeviceObject));
	KdPrint(("  Flags = 0x%x\n",p->Flags));
	KdPrint(("  DriverStart = %p\n",p->DriverStart));
	KdPrint(("  DriverSize = %d\n",p->DriverSize));
	KdPrint(("  DriverSection = %p\n",p->DriverSection));
	KdPrint(("  DriverExtension = %p\n",p->DriverExtension));
	KdPrint(("  DriverExtension->AddDevice = %p\n",p->DriverExtension->AddDevice));
	KdPrint(("  FastIoDispatch = %p\n",p->FastIoDispatch));
	KdPrint(("  DriverInit = %p\n",p->DriverInit));
	KdPrint(("  DriverStartIo = %p\n",p->DriverStartIo));
	KdPrint(("  DriverUnload = %p\n",p->DriverUnload));
	for (int i=0;i<IRP_MJ_MAXIMUM_FUNCTION + 1;i++)
		KdPrint(("  MajorFunction[%d] = %p\n",i,p->MajorFunction[i]));
}

void DumpDeviceObject(PDEVICE_OBJECT p)
{
	KdPrint(("UsbSnoop - DumpDeviceObject : p = %p\n",p));
	KdPrint(("  DriverObject = %p\n",p->DriverObject));
	KdPrint(("  NextDevice = %p\n",p->NextDevice));
	KdPrint(("  AttachedDevice = %p\n",p->AttachedDevice));
	KdPrint(("  StackSize=%d\n",p->StackSize));
	KdPrint(("  CurrentIrp = %p\n",p->CurrentIrp));
	KdPrint(("  DeviceObjectExtension = %p\n",p->DeviceObjectExtension));

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)p->DeviceObjectExtension;

	KdPrint(("   ->DeviceObject=%p\n",pdx->DeviceObject));
	KdPrint(("   ->LowerDeviceObject=%p\n",pdx->LowerDeviceObject));
	KdPrint(("   ->Pdo=%p\n",pdx->Pdo));
}

void DumpContext(PCONTEXT Context)
{
	KdPrint(("DumpContext : Context=%p\n",Context));
	KdPrint(("  CompletionRoutine=%p, Context=%p, Control=%x\n",
		Context->CompletionRoutine,Context->Context,Context->Control));
	KdPrint(("  pUrb=%p, uSequenceNumber=%d, Stack=%p\n",
		Context->pUrb,Context->uSequenceNumber,Context->Stack));
}

#pragma INITCODE

/*
	DriverEntry : this function is called whenever this driver is loaded in memory,
		this is the only entry point this is accessible for the OS. Other entry
		points will be set up inside DriverEntry().
*/

extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	UCHAR MajorVersion, MinorVersion;

	//	Jean-Sebastien Vallette 25 08 2001
	//	Decaration for log file
	NTSTATUS status;
	LARGE_INTEGER ByteOffset;
	


	KdPrint(("UsbSnoop compiled on " __DATE__ " " __TIME__ "\n"));
	// Valette Jean-Sébastien
	//
	//	LogThread initialisation
	//
	//	Added 09 09 2001
	//	04 10 2001 : Move Global Buffer variable initialisation here 
	//				 Because of late Thread Init ! (loggin begins before
	//				 end of thread initialisation)
	LogBuffer.EndPos = LogBuffer.EndPos = 0;
	status = PsCreateSystemThread( &ThreadHandle,THREAD_ALL_ACCESS ,0,
					0,0, LogToFile,0);

	//	Valette Jean-Sébastien 
	//
	//	Initialize Semaphore
	//
	//	Added 09 09 2001
	KeInitializeSemaphore(&DataToBeRead,0,10);



	ByteOffset.QuadPart = FILE_USE_FILE_POINTER_POSITION;
	
	// Insist that OS support at least the WDM 1.0 (Win98 DDK)
	
	if (!IoIsWdmVersionAvailable(1, 0))
	{
		KdPrint(("UsbSnoop - Expected version of WDM (%d.%2.2d) not available\n", 1, 0));
		return STATUS_UNSUCCESSFUL;
	}
	
	// See if we're running under Win98 or NT:
	
	win98 = !IoIsWdmVersionAvailable(1, 10); //DriverObject->DriverExtension->ServiceKeyName.Length == 0;
	
	MajorVersion = 0;
	MinorVersion = 0;

	while (IoIsWdmVersionAvailable(MajorVersion,MinorVersion))
		MajorVersion ++;

	MajorVersion --;

	while (IoIsWdmVersionAvailable(MajorVersion,MinorVersion))
		MinorVersion ++;
	MinorVersion --;

	if (win98)
		KdPrint(("UsbSnoop - DriverEntry(%p) : Windows 98 WDM version %d.%d\n",
			DriverEntry,MajorVersion,MinorVersion));
	else
		KdPrint(("UsbSnoop - DriverEntry(%p) : Windows NT WDM version %d.%d\n",
			DriverEntry,MajorVersion,MinorVersion));

//	DumpDriverObject(DriverObject);

	// Save the name of the service key

	servkey.Buffer = (PWSTR) ExAllocatePool(PagedPool, RegistryPath->MaximumLength);
	if (!servkey.Buffer)
	{
		KdPrint(("UsbSnoop - Unable to allocate %d bytes for copy of service key name\n", RegistryPath->MaximumLength));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	servkey.MaximumLength = RegistryPath->MaximumLength;
	RtlCopyUnicodeString(&servkey, RegistryPath);

	// Initialize function pointers

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->DriverExtension->AddDevice = AddDevice;
	
	for (int i = 0; i < arraysize(DriverObject->MajorFunction); ++i)
		DriverObject->MajorFunction[i] = DispatchAny;

	// POWER IRP needs a special treatment
	DriverObject->MajorFunction[IRP_MJ_POWER] = DispatchPower;

	// we need a special callback to call RemoveDevice().
	// this is now done in MyDispatchPnp
//	DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;

	// not needed
//	DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = DispatchWmi;

	// not needed
//	DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = DispatchInternalIOCTL;

//	DumpDriverObject(DriverObject);

	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////

#pragma PAGEDCODE

/*
	DriverUnload() is called whenever our driver is unloaded from memory.
*/

VOID DriverUnload(IN PDRIVER_OBJECT DriverObject)
{
	NTSTATUS status;
	PAGED_CODE();
	KdPrint(("UsbSnoop - DriverUnload(%p) : DriverObject %p\n",
		DriverUnload,DriverObject));
//	DumpDriverObject(DriverObject);
	RtlFreeUnicodeString(&servkey);
	Loging = FALSE;
	
	KdPrint(("usbsnoop : Closed File \n"));
	KdPrint(("usbsnoop: status %x\n",status));


}

const char * GetIrpPnpMinorFunctionName(ULONG fcn)
{
	static const char* fcnname[] =
	{
		"IRP_MN_START_DEVICE",
		"IRP_MN_QUERY_REMOVE_DEVICE",
		"IRP_MN_REMOVE_DEVICE",
		"IRP_MN_CANCEL_REMOVE_DEVICE",
		"IRP_MN_STOP_DEVICE",
		"IRP_MN_QUERY_STOP_DEVICE",
		"IRP_MN_CANCEL_STOP_DEVICE",
		"IRP_MN_QUERY_DEVICE_RELATIONS",
		"IRP_MN_QUERY_INTERFACE",
		"IRP_MN_QUERY_CAPABILITIES",
		"IRP_MN_QUERY_RESOURCES",
		"IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
		"IRP_MN_QUERY_DEVICE_TEXT",
		"IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
		"",
		"IRP_MN_READ_CONFIG",
		"IRP_MN_WRITE_CONFIG",
		"IRP_MN_EJECT",
		"IRP_MN_SET_LOCK",
		"IRP_MN_QUERY_ID",
		"IRP_MN_QUERY_PNP_DEVICE_STATE",
		"IRP_MN_QUERY_BUS_INFORMATION",
		"IRP_MN_DEVICE_USAGE_NOTIFICATION",
		"IRP_MN_SURPRISE_REMOVAL",
	};

	if (0<=fcn && fcn<arraysize(fcnname))
		return fcnname[fcn];

	return NULL;
}

NTSTATUS MyDispatchPnp(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char * MinorFunctionName = GetIrpPnpMinorFunctionName(fcn);
	if (MinorFunctionName != NULL)
		KdPrint(("UsbSnoop - MyDispatchPNP(%p) : IRP_MJ_PNP (%s)\n",
			MyDispatchPnp,MinorFunctionName));
	else
		KdPrint(("UsbSnoop - MyDispatchPNP(%p) : IRP_MJ_PNP (0x%x)\n",
			MyDispatchPnp,fcn));
	
	PDEVICE_OBJECT fido = fdo->AttachedDevice;
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;

	status = pdx->OriginalDriverObject->MajorFunction[IRP_MJ_PNP](fdo,Irp);	

	// the following lines should be executed ONLY if DispatchPNP() callback
	// is not used, since it duplicates its work.

	if (fcn == IRP_MN_REMOVE_DEVICE)
		RemoveDevice(fido);
	
	return status;
}

/*
	AddDevice is called for each device we have to managed. This is where we
	get the oportunity to be added in the device object stack.
*/

NTSTATUS AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT pdo)
{
	PAGED_CODE();
	KdPrint(("UsbSnoop - AddDevice(%p) : DriverObject %p, pdo %p\n",
		AddDevice,DriverObject, pdo));

//	DumpDriverObject(DriverObject);
//	DumpDeviceObject(pdo);


	NTSTATUS status;
	
	// Create a UsbSnoop device object to represent the hardware we're managing.
	
	PDEVICE_OBJECT fido;

	status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),NULL,
		FILE_DEVICE_UNKNOWN, 0, FALSE, &fido);
	if (!NT_SUCCESS(status))
	{						// can't create device object
		KdPrint(("UsbSnoop - IoCreateDevice failed - %X\n", status));
		return status;
	}						// can't create device object

	// Benoit PAPILLAULT 13/07/2001
	// fido->DeviceExtension is a user define structure whose size is passed
	// to IoCreateDevice(). We can store whatever we want inside.

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	
	// From this point forward, any error will have side effects that need to
	// be cleaned up. Using a try-finally block allows us to modify the program
	// easily without losing track of the side effects.
	
	__try
	{						// finish initialization
		IoInitializeRemoveLock(&pdx->RemoveLock, 0, 0, 255);
		pdx->DeviceObject = fido;
		pdx->Pdo = pdo;
		
		// Add our device object to the stack and propagate critical settings
		// from the immediately lower device object
		
		PDEVICE_OBJECT fdo = IoAttachDeviceToDeviceStack(fido, pdo);

		pdx->LowerDeviceObject = fdo;
		fido->Flags |= fdo->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE | DO_POWER_INRUSH);
		fido->DeviceType = fdo->DeviceType;
		fido->Characteristics = fdo->Characteristics;
		fido->AlignmentRequirement = fdo->AlignmentRequirement;
		
		// Clear the "initializing" flag so that we can get IRPs
		
		fido->Flags &= ~DO_DEVICE_INITIALIZING;

//		DumpDriverObject(DriverObject);
//		DumpDeviceObject(fdo);
//		DumpDeviceObject(fido);
//		DumpDeviceObject(pdo);

		// we make a copy of fdo->DriverObject
		PDRIVER_OBJECT d = (PDRIVER_OBJECT)ExAllocatePool(PagedPool,sizeof(DRIVER_OBJECT));
		if (d != NULL)
		{
			*d = *fdo->DriverObject;

			// we make some changes to this copy
			d->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = MyDispatchInternalIOCTL;
			d->MajorFunction[IRP_MJ_PNP]                     = MyDispatchPnp;

			// here is the trick : we save the original DriverObject
			// and next, it points to our modified copy
			pdx->OriginalDriverObject = fdo->DriverObject;
			fdo->DriverObject = d;

			KdPrint(("  OriginalDriverObject = %p\n",pdx->OriginalDriverObject));
		}
		else
			KdPrint(("ExAllocatePool failed : not redirecting PDO->DriverObject\n"));
	}						// finish initialization
	__finally
	{						// cleanup side effects
		if (!NT_SUCCESS(status))
		{					// need to cleanup
			IoDeleteDevice(fido);
		}					// need to cleanup
	}						// cleanup side effects
	
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE

NTSTATUS CompleteRequest(IN PIRP Irp, IN NTSTATUS status, IN ULONG info)
{
	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = info;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE				// make no assumptions about pageability of dispatch fcns

NTSTATUS DispatchAny(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	
	const char* irpname[] =
	{
		"IRP_MJ_CREATE",
		"IRP_MJ_CREATE_NAMED_PIPE",
		"IRP_MJ_CLOSE",
		"IRP_MJ_READ",
		"IRP_MJ_WRITE",
		"IRP_MJ_QUERY_INFORMATION",
		"IRP_MJ_SET_INFORMATION",
		"IRP_MJ_QUERY_EA",
		"IRP_MJ_SET_EA",
		"IRP_MJ_FLUSH_BUFFERS",
		"IRP_MJ_QUERY_VOLUME_INFORMATION",
		"IRP_MJ_SET_VOLUME_INFORMATION",
		"IRP_MJ_DIRECTORY_CONTROL",
		"IRP_MJ_FILE_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CONTROL",
		"IRP_MJ_INTERNAL_DEVICE_CONTROL",
		"IRP_MJ_SHUTDOWN",
		"IRP_MJ_LOCK_CONTROL",
		"IRP_MJ_CLEANUP",
		"IRP_MJ_CREATE_MAILSLOT",
		"IRP_MJ_QUERY_SECURITY",
		"IRP_MJ_SET_SECURITY",
		"IRP_MJ_POWER",
		"IRP_MJ_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CHANGE",
		"IRP_MJ_QUERY_QUOTA",
		"IRP_MJ_SET_QUOTA",
		"IRP_MJ_PNP",
	};
	
	UCHAR type = stack->MajorFunction;
	if (type >= arraysize(irpname))
		KdPrint(("UsbSnoop - DispatchAny : Unknown IRP, MajorFunction=0x%x\n", type));
	else
		KdPrint(("UsbSnoop - DispatchAny : %s\n", irpname[type]));
	
	// Pass request down without additional processing
	
	NTSTATUS status;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

void DumpBuffer(unsigned char * buf, int len)
{
#define NB_BYTE 16 /* number of bytes displayed per line */

	char str[NB_BYTE*3 + 1];

	for (int i=0;i<len;i+=NB_BYTE)
	{
		char * p = str;

		for (int j=i;j<len&&j<i+NB_BYTE;j++)
		{
			char c;

			*p++ = ' ';
			c = (buf[j] >> 4) & 0xf;
			*p++ = (c<10) ? c+'0' : c-10+'a';
			c = buf[j] & 0xf;
			*p++ = (c<10) ? c+'0' : c-10+'a';
		}
		*p = 0;

		KdPrint(("    %04x:%s\n",i,str));
	}
}

void DumpTransferBuffer(PUCHAR pBuffer, PMDL pMdl, ULONG uBufferSize, BOOLEAN bPrintHeader)
{
	if(bPrintHeader)
	{
		KdPrint(("  TransferBufferLength = %08x\n", uBufferSize));
		KdPrint(("  TransferBuffer       = %08x\n", pBuffer));
		KdPrint(("  TransferBufferMDL    = %08x\n", pMdl));
	}
	else
	{
		if(pBuffer)
		{
			if(pMdl)
			{
				//KdPrint(("??? weird transfer buffer, both MDL and flat specified. Ignoring MDL\n"));
			}
			DumpBuffer(pBuffer,uBufferSize);
		}
		else if(pMdl)
		{
			PUCHAR pMDLBuf = (PUCHAR)MmGetSystemAddressForMdl(pMdl);
			if(pMDLBuf)
				DumpBuffer(pMDLBuf,uBufferSize);
			else
			{
				KdPrint(("XXXXX ERROR: can't map MDL!\n"));
			}
		}
		else
		{
			KdPrint(("\n    no data supplied\n"));
		}
	}
}

void DumpGetStatusRequest(struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusRequest, BOOLEAN bReturnedFromHCD)
{
	DumpTransferBuffer((PUCHAR)pGetStatusRequest->TransferBuffer, pGetStatusRequest->TransferBufferMDL, pGetStatusRequest->TransferBufferLength, TRUE);
	if(pGetStatusRequest->TransferBufferLength != 1)
		KdPrint(("  *** error - TransferBufferLength should be 1!\n"));
	if(bReturnedFromHCD)
	{
		DumpTransferBuffer((PUCHAR)pGetStatusRequest->TransferBuffer, pGetStatusRequest->TransferBufferMDL, pGetStatusRequest->TransferBufferLength, FALSE);
	}

	KdPrint(("  Index                = %02x\n", pGetStatusRequest->Index));
	
	if(pGetStatusRequest->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pGetStatusRequest->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}
}

void DumpFeatureRequest(struct _URB_CONTROL_FEATURE_REQUEST *pFeatureRequest, BOOLEAN bReadFromDevice, BOOLEAN bReturnedFromHCD)
{
	KdPrint(("  FeatureSelector = %04x\n", pFeatureRequest->FeatureSelector));
	KdPrint(("  Index           = %04x\n", pFeatureRequest->Index));
	if(pFeatureRequest->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pFeatureRequest->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}
}

void DumpDescriptorRequest(struct _URB_CONTROL_DESCRIPTOR_REQUEST *pDescriptorRequest, BOOLEAN bReadFromDevice, BOOLEAN bReturnedFromHCD)
{
	DumpTransferBuffer((PUCHAR)pDescriptorRequest->TransferBuffer, pDescriptorRequest->TransferBufferMDL, pDescriptorRequest->TransferBufferLength, TRUE);
	if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
	{
		DumpTransferBuffer((PUCHAR)pDescriptorRequest->TransferBuffer, pDescriptorRequest->TransferBufferMDL, pDescriptorRequest->TransferBufferLength, FALSE);
	}

	KdPrint(("  Index                = %02x\n", pDescriptorRequest->Index));
	KdPrint(("  DescriptorType       = %02x (%s)\n", pDescriptorRequest->DescriptorType,
		pDescriptorRequest->DescriptorType == USB_DEVICE_DESCRIPTOR_TYPE ? "USB_DEVICE_DESCRIPTOR_TYPE" :
		pDescriptorRequest->DescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE ? "USB_CONFIGURATION_DESCRIPTOR_TYPE" :
		pDescriptorRequest->DescriptorType == USB_STRING_DESCRIPTOR_TYPE ? "USB_STRING_DESCRIPTOR_TYPE" : "<illegal descriptor type!>"));
	KdPrint(("  LanguageId           = %04x\n", pDescriptorRequest->LanguageId));
	
	if(pDescriptorRequest->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pDescriptorRequest->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}
}

void DumpVendorOrClassRequest(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassInterface, BOOLEAN bReturnedFromHCD)
{
	BOOLEAN bReadFromDevice = (BOOLEAN)(pFunctionClassInterface->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
	KdPrint(("  TransferFlags          = %08x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pFunctionClassInterface->TransferFlags,
		bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
		pFunctionClassInterface->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~"));

	DumpTransferBuffer((PUCHAR)pFunctionClassInterface->TransferBuffer, pFunctionClassInterface->TransferBufferMDL, pFunctionClassInterface->TransferBufferLength, TRUE);
	if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
	{
		DumpTransferBuffer((PUCHAR)pFunctionClassInterface->TransferBuffer, pFunctionClassInterface->TransferBufferMDL, pFunctionClassInterface->TransferBufferLength, FALSE);
	}

	KdPrint(("  UrbLink                 = %08x\n", pFunctionClassInterface->UrbLink));
	KdPrint(("  RequestTypeReservedBits = %02x\n", pFunctionClassInterface->RequestTypeReservedBits));
	KdPrint(("  Request                 = %02x\n", pFunctionClassInterface->Request));
	KdPrint(("  Value                   = %04x\n", pFunctionClassInterface->Value));
	KdPrint(("  Index                   = %04x\n", pFunctionClassInterface->Index));
	if(pFunctionClassInterface->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pFunctionClassInterface->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}

}

void DumpPipeHandle(const char *s,USBD_PIPE_HANDLE inPipeHandle)
{
	unsigned char ep;

	// search for the matching endpoint

	if (GetEndpointInfo(inPipeHandle,&ep))
		KdPrint(("%s = %p [endpoint 0x%x]\n",s,inPipeHandle,ep));
	else
		KdPrint(("%s = %p\n",s,inPipeHandle));
}

void DumpURB(PURB pUrb, BOOLEAN bReturnedFromHCD)
{
	if(NULL == pUrb)
	{
		KdPrint(("UsbSnoop - URB == NULL ???\n"));
		return;
	}

	USHORT wFunction = pUrb->UrbHeader.Function;
	USHORT wLength = pUrb->UrbHeader.Length;
	USBD_STATUS lUsbdStatus = pUrb->UrbHeader.Status;

	/* Status values are defined in <usbdi.h> as USBD_STATUS_XXX */
//	KdPrint(("  Header.Length = %d\n",          pUrb->UrbHeader.Length));
//	KdPrint(("  Header.Function = 0x%x\n",      pUrb->UrbHeader.Function));
//	KdPrint(("  Header.Status = 0x%x\n",        pUrb->UrbHeader.Status));
//	KdPrint(("  Header.UsbdDeviceHandle = %p\n",pUrb->UrbHeader.UsbdDeviceHandle));
//	KdPrint(("  Header.UsbdFlags = 0x%x\n",     pUrb->UrbHeader.UsbdFlags));

	switch(wFunction)
	{
	case URB_FUNCTION_SELECT_CONFIGURATION:
		{

			/* _URB_SELECT_CONFIGURATION is as follows :

			- a first block of 16 bytes : struct _URB_HEADER Hdr
			- a pointer (4 byes) : PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
			      this can be a NULL pointer, in which case the array of USBD_INTERFACE_INFORMATION
				  is empty.
			- a handle (4 bytes) : USBD_CONFIGURATION_HANDLE ConfigurationHandle
			- an array of USBD_INTERFACE_INFORMATION, whose number are
			    ConfigurationDescriptor.bNumInterfaces

			each USBD_INTERFACE_INFORMATION contains fixed information (16 bytes), followed
			  by an array of USB_PIPE_INFORMATION (20 bytes) whose number is NumberOfPipes.
			*/

#define URB_SELECT_CONFIGURATION_SIZE 24

			struct _URB_SELECT_CONFIGURATION *pSelectConfiguration = (struct _URB_SELECT_CONFIGURATION*) pUrb;
			KdPrint(("-- URB_FUNCTION_SELECT_CONFIGURATION:\n"));
			if(pSelectConfiguration->Hdr.Length < URB_SELECT_CONFIGURATION_SIZE)
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
					pSelectConfiguration->Hdr.Length,URB_SELECT_CONFIGURATION_SIZE));

			PUSB_CONFIGURATION_DESCRIPTOR pCD = pSelectConfiguration->ConfigurationDescriptor;
			KdPrint(("  ConfigurationDescriptor = 0x%x %s\n",pCD,pCD ? "(configure)":"(unconfigure)"));
			if (pCD == NULL)
				break;

			KdPrint(("  ConfigurationDescriptor : bLength             = %d\n", pCD->bLength));
			KdPrint(("  ConfigurationDescriptor : bDescriptorType     = 0x%02x\n", pCD->bDescriptorType));
			KdPrint(("  ConfigurationDescriptor : wTotalLength        = 0x%04x\n", pCD->wTotalLength));
			KdPrint(("  ConfigurationDescriptor : bNumInterfaces      = 0x%02x\n", pCD->bNumInterfaces));
			KdPrint(("  ConfigurationDescriptor : bConfigurationValue = 0x%02x\n", pCD->bConfigurationValue));
			KdPrint(("  ConfigurationDescriptor : iConfiguration      = 0x%02x\n", pCD->iConfiguration));
			KdPrint(("  ConfigurationDescriptor : bmAttributes        = 0x%02x\n", pCD->bmAttributes));
			KdPrint(("  ConfigurationDescriptor : MaxPower            = 0x%02x\n", pCD->MaxPower));
			KdPrint(("  ConfigurationHandle     = 0x%08x\n", pSelectConfiguration->ConfigurationHandle));
			
			ULONG uNumInterfaces = pCD->bNumInterfaces;

			if(uNumInterfaces > 0xff)
			{
				KdPrint(("XXXXXX ERROR: uNumInterfaces is too large (%d), resetting to 1\n", uNumInterfaces));
				uNumInterfaces = 1;
			}
			
			
			PUSBD_INTERFACE_INFORMATION pInterface = &pSelectConfiguration->Interface;
			for(ULONG i = 0; i < uNumInterfaces; i++)
			{
				KdPrint(("  Interface[%d]: Length            = %d\n", i, pInterface->Length));
				KdPrint(("  Interface[%d]: InterfaceNumber   = %d\n", i, pInterface->InterfaceNumber));
				KdPrint(("  Interface[%d]: AlternateSetting  = %d\n", i, pInterface->AlternateSetting));
				if(bReturnedFromHCD)
				{
					ULONG uNumPipes;
					KdPrint(("  Interface[%d]: Class             = 0x%02x\n", i, pInterface->Class));
					KdPrint(("  Interface[%d]: SubClass          = 0x%02x\n", i, pInterface->SubClass));
					KdPrint(("  Interface[%d]: Protocol          = 0x%02x\n", i, pInterface->Protocol));
					KdPrint(("  Interface[%d]: InterfaceHandle   = 0x%08x\n", i, pInterface->InterfaceHandle));
					KdPrint(("  Interface[%d]: NumberOfPipes     = %d\n", i, pInterface->NumberOfPipes));
					
					uNumPipes = pInterface->NumberOfPipes;
					if(uNumPipes > 0x1f)
					{
						KdPrint(("XXXXXX ERROR: uNumPipes is too large (%d), resetting to 1\n", uNumPipes));
						uNumPipes = 1;
					}
					for(ULONG p = 0; p< uNumPipes; p++)
					{
						KdPrint(("  Interface[%d]: Pipes[%lu] : MaximumPacketSize = 0x%04x\n", i, p, pInterface->Pipes[p].MaximumPacketSize));
						KdPrint(("  Interface[%d]: Pipes[%lu] : EndpointAddress   = 0x%02x\n", i, p, pInterface->Pipes[p].EndpointAddress));
						KdPrint(("  Interface[%d]: Pipes[%lu] : Interval          = 0x%02x\n", i, p, pInterface->Pipes[p].Interval));
						KdPrint(("  Interface[%d]: Pipes[%lu] : PipeType          = 0x%02x (%s)\n", i, p, pInterface->Pipes[p].PipeType,
							pInterface->Pipes[p].PipeType == UsbdPipeTypeControl ? "UsbdPipeTypeControl" :
						pInterface->Pipes[p].PipeType == UsbdPipeTypeIsochronous ? "UsbdPipeTypeIsochronous" :
						pInterface->Pipes[p].PipeType == UsbdPipeTypeBulk ? "UsbdPipeTypeBulk" :
						pInterface->Pipes[p].PipeType == UsbdPipeTypeInterrupt ? "UsbdPipeTypeInterrupt" : "!!! INVALID !!!"
							));
						KdPrint(("  Interface[%d]: Pipes[%lu] : PipeHandle        = 0x%p\n", i, p, pInterface->Pipes[p].PipeHandle));
						KdPrint(("  Interface[%d]: Pipes[%lu] : MaxTransferSize   = 0x%08x\n", i, p, pInterface->Pipes[p].MaximumTransferSize));
						KdPrint(("  Interface[%d]: Pipes[%lu] : PipeFlags         = 0x%02x\n", i, p, pInterface->Pipes[p].PipeFlags));

						AddEndpointInfo(pInterface->Pipes[p].PipeHandle,
							pInterface->Pipes[p].EndpointAddress);
					}
				}

				pInterface = (PUSBD_INTERFACE_INFORMATION) (((UCHAR*)pInterface) + pInterface->Length);
			}
		}
		break;

	case URB_FUNCTION_SELECT_INTERFACE:
		{
			struct _URB_SELECT_INTERFACE  *pSelectInterface = (struct _URB_SELECT_INTERFACE *) pUrb;

			KdPrint(("-- URB_FUNCTION_SELECT_INTERFACE:\n"));
			if(pSelectInterface->Hdr.Length < sizeof(struct _URB_SELECT_INTERFACE))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSelectInterface->Hdr.Length, sizeof(struct _URB_SELECT_INTERFACE)));
			KdPrint(("  ConfigurationHandle     = 0x%08x\n", pSelectInterface->ConfigurationHandle));

			PUSBD_INTERFACE_INFORMATION pInterface = &pSelectInterface->Interface;
			
			KdPrint(("  Interface: Length            = %d\n", pInterface->Length));
			KdPrint(("  Interface: InterfaceNumber   = %d\n", pInterface->InterfaceNumber));
			KdPrint(("  Interface: AlternateSetting  = %d\n", pInterface->AlternateSetting));
			KdPrint(("  Interface: Class             = 0x%02x\n", pInterface->Class));
			KdPrint(("  Interface: SubClass          = 0x%02x\n", pInterface->SubClass));
			KdPrint(("  Interface: Protocol          = 0x%02x\n", pInterface->Protocol));
			KdPrint(("  Interface: InterfaceHandle   = %p\n", pInterface->InterfaceHandle));
			KdPrint(("  Interface: NumberOfPipes     = %d\n", pInterface->NumberOfPipes));
			if(bReturnedFromHCD)
			{
				ULONG uNumPipes = pInterface->NumberOfPipes;
				if(uNumPipes > 0x1f)
				{
					KdPrint(("XXXXXX ERROR: uNumPipes is too large (%d), resetting to 1\n", uNumPipes));
					uNumPipes = 1;
				}
				for(ULONG p = 0; p< uNumPipes; p++)
				{
					KdPrint(("  Interface: Pipes[%lu] : MaximumPacketSize = 0x%04x\n", p, pInterface->Pipes[p].MaximumPacketSize));
					KdPrint(("  Interface: Pipes[%lu] : EndpointAddress   = 0x%02x\n", p, pInterface->Pipes[p].EndpointAddress));
					KdPrint(("  Interface: Pipes[%lu] : Interval          = 0x%02x\n", p, pInterface->Pipes[p].Interval));
					KdPrint(("  Interface: Pipes[%lu] : PipeType          = 0x%02x (%s)\n", p, pInterface->Pipes[p].PipeType,
						pInterface->Pipes[p].PipeType == UsbdPipeTypeControl ? "UsbdPipeTypeControl" :
					pInterface->Pipes[p].PipeType == UsbdPipeTypeIsochronous ? "UsbdPipeTypeIsochronous" :
					pInterface->Pipes[p].PipeType == UsbdPipeTypeBulk ? "UsbdPipeTypeBulk" :
					pInterface->Pipes[p].PipeType == UsbdPipeTypeInterrupt ? "UsbdPipeTypeInterrupt" : "!!! INVALID !!!"
						));
					KdPrint(("  Interface: Pipes[%lu] : PipeHandle        = 0x%p\n", p, pInterface->Pipes[p].PipeHandle));
					KdPrint(("  Interface: Pipes[%lu] : MaxTransferSize   = 0x%08x\n", p, pInterface->Pipes[p].MaximumTransferSize));
					KdPrint(("  Interface: Pipes[%lu] : PipeFlags         = 0x%02x\n", p, pInterface->Pipes[p].PipeFlags));

					AddEndpointInfo(pInterface->Pipes[p].PipeHandle,
						pInterface->Pipes[p].EndpointAddress);
				}
			}
		}
		break;
	case URB_FUNCTION_ABORT_PIPE:
		{
			struct _URB_PIPE_REQUEST   *pAbortPipe = (struct _URB_PIPE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_ABORT_PIPE:\n"));
			if(pAbortPipe->Hdr.Length < sizeof(struct _URB_PIPE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pAbortPipe->Hdr.Length, sizeof(struct _URB_PIPE_REQUEST)));

			if(!bReturnedFromHCD)
				DumpPipeHandle("  PipeHandle",pAbortPipe->PipeHandle);
		}
		break;
	case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
		{
			struct _URB_FRAME_LENGTH_CONTROL *pFrameLengthControl = (struct _URB_FRAME_LENGTH_CONTROL *) pUrb;

			KdPrint(("-- URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:\n"));
			if(pFrameLengthControl->Hdr.Length < sizeof(struct _URB_FRAME_LENGTH_CONTROL))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFrameLengthControl->Hdr.Length, sizeof(struct _URB_FRAME_LENGTH_CONTROL)));

			KdPrint(("  (no parameters)\n"));
		}
		break;
	case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
		{
			struct _URB_FRAME_LENGTH_CONTROL *pFrameLengthControl = (struct _URB_FRAME_LENGTH_CONTROL *) pUrb;

			KdPrint(("-- URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:\n"));
			if(pFrameLengthControl->Hdr.Length < sizeof(struct _URB_FRAME_LENGTH_CONTROL))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFrameLengthControl->Hdr.Length, sizeof(struct _URB_FRAME_LENGTH_CONTROL)));

			KdPrint(("  (no parameters)\n"));
		}
		break;
	case URB_FUNCTION_GET_FRAME_LENGTH:
		{
			struct _URB_GET_FRAME_LENGTH   *pGetFrameLength = (struct _URB_GET_FRAME_LENGTH *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_FRAME_LENGTH:\n"));
			if(pGetFrameLength->Hdr.Length < sizeof(struct _URB_GET_FRAME_LENGTH))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetFrameLength->Hdr.Length, sizeof(struct _URB_GET_FRAME_LENGTH)));

			if(bReturnedFromHCD)
			{
				KdPrint(("  FrameLength = %08x\n", pGetFrameLength->FrameLength));
				KdPrint(("  FrameNumber = %08x\n", pGetFrameLength->FrameNumber));
			}
		}
		break;
	case URB_FUNCTION_SET_FRAME_LENGTH:
		{
			struct _URB_SET_FRAME_LENGTH   *pSetFrameLength = (struct _URB_SET_FRAME_LENGTH *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FRAME_LENGTH:\n"));
			if(pSetFrameLength->Hdr.Length < sizeof(struct _URB_SET_FRAME_LENGTH))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFrameLength->Hdr.Length, sizeof(struct _URB_SET_FRAME_LENGTH)));

			if(!bReturnedFromHCD)
				KdPrint(("  FrameLengthDelta = %08x\n", pSetFrameLength->FrameLengthDelta));
		}
		break;
	case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
		{
			struct _URB_GET_CURRENT_FRAME_NUMBER   *pGetCurrentFrameNumber = (struct _URB_GET_CURRENT_FRAME_NUMBER *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:\n"));
			if(pGetCurrentFrameNumber->Hdr.Length < sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetCurrentFrameNumber->Hdr.Length, sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER)));

			if(bReturnedFromHCD)
				KdPrint(("  FrameNumber = %08x\n", pGetCurrentFrameNumber->FrameNumber));
		}
		break;
	case URB_FUNCTION_CONTROL_TRANSFER:
		{
			struct _URB_CONTROL_TRANSFER   *pControlTransfer = (struct _URB_CONTROL_TRANSFER *) pUrb;

			KdPrint(("-- URB_FUNCTION_CONTROL_TRANSFER:\n"));
			if(pControlTransfer->Hdr.Length < sizeof(struct _URB_CONTROL_TRANSFER))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pControlTransfer->Hdr.Length, sizeof(struct _URB_CONTROL_TRANSFER)));

			BOOLEAN bReadFromDevice = (BOOLEAN)(pControlTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle("  PipeHandle          ",pControlTransfer->PipeHandle);
			KdPrint(("  TransferFlags        = %08x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pControlTransfer->TransferFlags,
				bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
				pControlTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~"));
			DumpTransferBuffer((PUCHAR)pControlTransfer->TransferBuffer, pControlTransfer->TransferBufferMDL, pControlTransfer->TransferBufferLength, TRUE);
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer((PUCHAR)pControlTransfer->TransferBuffer, pControlTransfer->TransferBufferMDL, pControlTransfer->TransferBufferLength, FALSE);
			}

			KdPrint(("  UrbLink              = %08x\n", pControlTransfer->UrbLink));
			KdPrint(("  SetupPacket          :"));

			for(int b=0; b<sizeof(pControlTransfer->SetupPacket); b++)
				KdPrint((" %02x", pControlTransfer->SetupPacket[b]));
			KdPrint(("\n"));
			if(pControlTransfer->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pControlTransfer->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
		{
			struct _URB_BULK_OR_INTERRUPT_TRANSFER *pBulkOrInterruptTransfer = (struct _URB_BULK_OR_INTERRUPT_TRANSFER *) pUrb;

			KdPrint(("-- URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:\n"));
			if(pBulkOrInterruptTransfer->Hdr.Length < sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER ))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pBulkOrInterruptTransfer->Hdr.Length, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER)));

			BOOLEAN bReadFromDevice = (BOOLEAN)(pBulkOrInterruptTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle("  PipeHandle          ",pBulkOrInterruptTransfer->PipeHandle);
			KdPrint(("  TransferFlags        = %08x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pBulkOrInterruptTransfer->TransferFlags,
				bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
				pBulkOrInterruptTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~"));
			DumpTransferBuffer((PUCHAR)pBulkOrInterruptTransfer->TransferBuffer, pBulkOrInterruptTransfer->TransferBufferMDL, pBulkOrInterruptTransfer->TransferBufferLength, TRUE);
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer((PUCHAR)pBulkOrInterruptTransfer->TransferBuffer, pBulkOrInterruptTransfer->TransferBufferMDL, pBulkOrInterruptTransfer->TransferBufferLength, FALSE);
			}

			KdPrint(("  UrbLink              = %08x\n", pBulkOrInterruptTransfer->UrbLink));
			if(pBulkOrInterruptTransfer->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pBulkOrInterruptTransfer->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_ISOCH_TRANSFER:
		{
			struct _URB_ISOCH_TRANSFER *pIsochTransfer = (struct _URB_ISOCH_TRANSFER *) pUrb;

			KdPrint(("-- URB_FUNCTION_ISOCH_TRANSFER:\n"));
			if(pIsochTransfer->Hdr.Length < sizeof(struct _URB_ISOCH_TRANSFER ))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pIsochTransfer->Hdr.Length, sizeof(struct _URB_ISOCH_TRANSFER)));

			BOOLEAN bReadFromDevice = (BOOLEAN)(pIsochTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle("  PipeHandle          ",pIsochTransfer->PipeHandle);
			KdPrint(("  TransferFlags        = %08x (%s, %sUSBD_SHORT_TRANSFER_OK%sn", pIsochTransfer->TransferFlags,
				bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
				pIsochTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~",
				pIsochTransfer->TransferFlags & USBD_START_ISO_TRANSFER_ASAP ? ", USBD_START_ISO_TRANSFER_ASAP" : ""));
			DumpTransferBuffer((PUCHAR)pIsochTransfer->TransferBuffer, pIsochTransfer->TransferBufferMDL, pIsochTransfer->TransferBufferLength, TRUE);
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer((PUCHAR)pIsochTransfer->TransferBuffer, pIsochTransfer->TransferBufferMDL, pIsochTransfer->TransferBufferLength, FALSE);
			}

			KdPrint(("  StartFrame           = %08x\n", pIsochTransfer->StartFrame));
			KdPrint(("  NumberOfPackets      = %08x\n", pIsochTransfer->NumberOfPackets));
			if(bReturnedFromHCD)
				KdPrint(("  ErrorCount           = %08x\n", pIsochTransfer->ErrorCount));
			for(ULONG p=0; p < pIsochTransfer->NumberOfPackets; p++)
			{
				KdPrint(("  IsoPacket[%d].Offset = %08x\n", pIsochTransfer->IsoPacket[p].Offset));
				KdPrint(("  IsoPacket[%d].Length = %08x\n", pIsochTransfer->IsoPacket[p].Length));
				if(bReturnedFromHCD)
					KdPrint(("  IsoPacket[%d].Status = %08x\n", pIsochTransfer->IsoPacket[p].Status));
			}
			KdPrint(("  UrbLink              = %08x\n", pIsochTransfer->UrbLink));
			if(pIsochTransfer->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pIsochTransfer->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_RESET_PIPE:
		{
			struct _URB_PIPE_REQUEST   *pResetPipe = (struct _URB_PIPE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_RESET_PIPE:\n"));
			if(pResetPipe->Hdr.Length < sizeof(struct _URB_PIPE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pResetPipe->Hdr.Length, sizeof(struct _URB_PIPE_REQUEST)));

			if(!bReturnedFromHCD)
				DumpPipeHandle("  PipeHandle",pResetPipe->PipeHandle);
		}
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromDevice = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:\n"));
			if(pGetDescriptorFromDevice->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromDevice->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pGetDescriptorFromDevice, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromEndpoint = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:\n"));
			if(pGetDescriptorFromEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pGetDescriptorFromEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromInterface = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:\n"));
			if(pGetDescriptorFromInterface->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromInterface->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pGetDescriptorFromInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToDevice = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:\n"));
			if(pSetDescriptorToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pSetDescriptorToDevice, FALSE, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToEndpoint = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:\n"));
			if(pSetDescriptorToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pSetDescriptorToEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToInterface = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:\n"));
			if(pSetDescriptorToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pSetDescriptorToInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToDevice = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_DEVICE:\n"));
			if(pSetFeatureToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToDevice, TRUE, bReturnedFromHCD);
 
		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToInterface = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_INTERFACE:\n"));
			if(pSetFeatureToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToEndpoint = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:\n"));
			if(pSetFeatureToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_OTHER:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToOther = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_OTHER:\n"));
			if(pSetFeatureToOther->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToOther->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToOther, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToDevice = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:\n"));
			if(pClearFeatureToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToDevice, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToInterface = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:\n"));
			if(pClearFeatureToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToEndpoint = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:\n"));
			if(pClearFeatureToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToOther = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:\n"));
			if(pClearFeatureToOther->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToOther->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToOther, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromDevice = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_DEVICE:\n"));
			if(pGetStatusFromDevice->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromDevice->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromDevice, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromInterface = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_INTERFACE:\n"));
			if(pGetStatusFromInterface->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromInterface->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromInterface, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromEndpoint = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:\n"));
			if(pGetStatusFromEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromEndpoint, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_OTHER:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromOther = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_OTHER:\n"));
			if(pGetStatusFromOther->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromOther->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromOther, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_VENDOR_DEVICE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorDevice = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_DEVICE:\n"));
			if(pFunctionVendorDevice->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorDevice->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorDevice, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_VENDOR_INTERFACE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorInterface = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_INTERFACE:\n"));
			if(pFunctionVendorInterface->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorInterface->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorInterface, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_VENDOR_ENDPOINT:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorEndpoint = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_ENDPOINT:\n"));
			if(pFunctionVendorEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorEndpoint, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_VENDOR_OTHER:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorOther = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_OTHER:\n"));
			if(pFunctionVendorOther->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorOther->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorOther, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_DEVICE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassDevice = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_DEVICE:\n"));
			if(pFunctionClassDevice->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassDevice->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassDevice, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_INTERFACE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassInterface = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_INTERFACE:\n"));
			if(pFunctionClassInterface->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassInterface->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassInterface, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_ENDPOINT:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassEndpoint = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_ENDPOINT:\n"));
			if(pFunctionClassEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassEndpoint, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_OTHER:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassOther = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_OTHER:\n"));
			if(pFunctionClassOther->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassOther->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassOther, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_GET_CONFIGURATION:
		{
			struct _URB_CONTROL_GET_CONFIGURATION_REQUEST *pGetConfiguration = (struct _URB_CONTROL_GET_CONFIGURATION_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_CONFIGURATION:\n"));
			if(pGetConfiguration->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetConfiguration->Hdr.Length, sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST)));

			DumpTransferBuffer((PUCHAR)pGetConfiguration->TransferBuffer, pGetConfiguration->TransferBufferMDL, pGetConfiguration->TransferBufferLength, TRUE);
			if(pGetConfiguration->TransferBufferLength != 1)
				KdPrint(("  *** error - TransferBufferLength should be 1!\n"));

			if(bReturnedFromHCD)
			{
				DumpTransferBuffer((PUCHAR)pGetConfiguration->TransferBuffer, pGetConfiguration->TransferBufferMDL, pGetConfiguration->TransferBufferLength, FALSE);
			}

			KdPrint(("  UrbLink              = %08x\n", pGetConfiguration->UrbLink));
			if(pGetConfiguration->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pGetConfiguration->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_GET_INTERFACE:
		{
			struct _URB_CONTROL_GET_INTERFACE_REQUEST *pGetInterface = (struct _URB_CONTROL_GET_INTERFACE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_INTERFACE:\n"));
			if(pGetInterface->Hdr.Length < sizeof(struct _URB_CONTROL_GET_INTERFACE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetInterface->Hdr.Length, sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST)));

			DumpTransferBuffer((PUCHAR)pGetInterface->TransferBuffer, pGetInterface->TransferBufferMDL, pGetInterface->TransferBufferLength, TRUE);
			if(pGetInterface->TransferBufferLength != 1)
				KdPrint(("  *** error - TransferBufferLength should be 1!\n"));

			if(bReturnedFromHCD)
			{
				DumpTransferBuffer((PUCHAR)pGetInterface->TransferBuffer, pGetInterface->TransferBufferMDL, pGetInterface->TransferBufferLength, FALSE);
			}

			KdPrint(("  Interface            = %02x\n", pGetInterface->UrbLink));
			KdPrint(("  UrbLink              = %08x\n", pGetInterface->UrbLink));
			if(pGetInterface->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pGetInterface->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;

	default:
		KdPrint(("******* non printable URB with function code 0x%04x ********\n", wFunction));
		break;
	}	// end of mega switch
	KeReleaseSemaphore(&DataToBeRead,0,1,FALSE);
}

NTSTATUS InternalIOCTLCompletion(IN PDEVICE_OBJECT fido, IN PIRP Irp, IN PVOID Context)
{
	KdPrint(("UsbSnoop - InternalIOCTLCompletion(%p) : fido=%p, Irp=%p, Context=%p\n",
		InternalIOCTLCompletion,fido,Irp,Context));
//	DumpIrp(Irp);

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

    if (Irp->PendingReturned) {
		KdPrint(("  IoMarkIrpPending\n"));
        IoMarkIrpPending( Irp );
    }

	ULONG uSequenceNumber = (ULONG)Context;
	ULONG dwControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
	if(IOCTL_INTERNAL_USB_SUBMIT_URB == dwControlCode)
	{
		KdPrint(("~<<<~ URB %d coming back ~<<<~\n", uSequenceNumber));
		PURB pUrb = (PURB)stack->Parameters.Others.Argument1;
		DumpURB(pUrb, TRUE);
	}
// TODO: check this line with the one in the downward irp handler! //	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return STATUS_SUCCESS;
}

NTSTATUS MyInternalIOCTLCompletion(IN PDEVICE_OBJECT fido, IN PIRP Irp, IN PVOID inContext)
{
	KdPrint(("UsbSnoop - MyInternalIOCTLCompletion(%p) : fido=%p, Irp=%p, Context=%p\n",
		MyInternalIOCTLCompletion,fido,Irp,inContext));

//	DumpIrp(Irp);

	PCONTEXT Context = (PCONTEXT)inContext;
//	DumpContext(Context);

	// restoring information.

	Context->Stack->CompletionRoutine = Context->CompletionRoutine;
	Context->Stack->Context           = Context->Context;
	Context->Stack->Control           = Context->Control;

	// dumping URB 
	KdPrint((" <<<  URB %d coming back  <<< \n",Context->uSequenceNumber));
	DumpURB(Context->pUrb, TRUE);


	// saving some field before freeing the structure
	PVOID OldContext = Context->Context;
	PIO_COMPLETION_ROUTINE OldCompletionRoutine = Context->CompletionRoutine;

	// freeing the allocated structure
	ExFreePool(Context);

	// calling the old CompletionRoutine, if there was one

	if (OldCompletionRoutine != NULL)
		return OldCompletionRoutine(fido,Irp,OldContext);

	return STATUS_SUCCESS;
}

NTSTATUS MyDispatchInternalIOCTL(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
	KdPrint(("UsbSnoop - MyDispatchInternalIOCTL(%p) : fdo=%p, Irp=%p\n",
		MyDispatchInternalIOCTL,fdo,Irp));
//	DumpDeviceObject(fdo);
//	DumpIrp(Irp);

	// we want to recover OriginalDriverObject which is stored in fido,
	// so we need to recover fido first, by the AttachedDevice field from FDO.

	PDEVICE_OBJECT fido = fdo->AttachedDevice;
//	KdPrint(("  fido = %p\n",fido));

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
//	KdPrint(("  OriginalDriverObject = %p\n",pdx->OriginalDriverObject));

	// try to print the URB 

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG dwControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
//	KdPrint(("  dwControlCode=%d\n",dwControlCode));
	if (dwControlCode == IOCTL_INTERNAL_USB_SUBMIT_URB)
	{
		ULONG uSequenceNumber = InterlockedIncrement((PLONG)&pdx->uSequenceNumber);
		KdPrint((" >>>  URB %d going down  >>> \n", uSequenceNumber));
		FillRollingBuffer(" >>>  URB %d going down  >>>\n");

		PURB pUrb = (PURB) stack->Parameters.Others.Argument1;
		DumpURB(pUrb,FALSE);

		// inspired from the macro code of IoSetCompletionRoutine
		// it just makes a big BSOD

		// ok. in fact, it worked, but that particular case,
		// the first parameter of the IoCompletionRoutine is NULL instead of being fido !!!

		// normalling, there should be a call to IoCopyCurrentIrpStackLocationToNext()
		// which might not be there. So, we are surely replacing other callbacks.

		// first, we saved every information we'll modify later

		PCONTEXT Context = (PCONTEXT)ExAllocatePool(PagedPool,sizeof(CONTEXT));
		if (Context != NULL)
		{
			Context->CompletionRoutine = stack->CompletionRoutine;
			Context->Context           = stack->Context;
			Context->Control           = stack->Control;
			Context->pUrb              = pUrb;
			Context->uSequenceNumber   = uSequenceNumber;
			Context->Stack             = stack;

//			KdPrint(("  Replacing %p/%p/%p by ",
//				stack->CompletionRoutine,stack->Context,stack->Control));
			stack->CompletionRoutine = MyInternalIOCTLCompletion;
			stack->Context = Context;
			stack->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

//			KdPrint(("%p/%p/%p\n",stack->CompletionRoutine,stack->Context,stack->Control));
		}
		else
			KdPrint(("  ExAllocatePool failed! Can't redirect CompletionRoutine\n"));
	}

	return pdx->OriginalDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL](fdo,Irp);
}

NTSTATUS DispatchInternalIOCTL(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

	KdPrint(("UsbSnoop - DispatchInternalIOCTL(%p) : fido=%p, Irp=%p\n",
		DispatchInternalIOCTL,fido,Irp));
//	DumpDeviceObject(fido);
//	DumpIrp(Irp);
	
	UCHAR type = stack->MinorFunction;
	PCHAR pFuncName = NULL;

	ULONG dwControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
	switch(dwControlCode)
	{
	case IOCTL_INTERNAL_USB_SUBMIT_URB:
		pFuncName = "IOCTL_INTERNAL_USB_SUBMIT_URB";
		break;

	case IOCTL_INTERNAL_USB_RESET_PORT:
		pFuncName = "IOCTL_INTERNAL_USB_RESET_PORT";
		break;

	case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
		pFuncName = "IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO";
		break;

	case IOCTL_INTERNAL_USB_GET_PORT_STATUS:
		pFuncName = "IOCTL_INTERNAL_USB_GET_PORT_STATUS";
		break;

	case IOCTL_INTERNAL_USB_ENABLE_PORT:
		pFuncName = "IOCTL_INTERNAL_USB_ENABLE_PORT";
		break;

	case IOCTL_INTERNAL_USB_GET_HUB_COUNT:
		pFuncName = "IOCTL_INTERNAL_USB_GET_HUB_COUNT";
		break;

	case IOCTL_INTERNAL_USB_CYCLE_PORT:
		pFuncName = "IOCTL_INTERNAL_USB_CYCLE_PORT";
		break;
// following IOCTL_XXX are not defined under Windows 98 DDK
/*
	case IOCTL_INTERNAL_USB_GET_HUB_NAME:
		pFuncName = "IOCTL_INTERNAL_USB_GET_HUB_NAME";
		break;

	case IOCTL_INTERNAL_USB_GET_BUS_INFO:
		pFuncName = "IOCTL_INTERNAL_USB_GET_BUS_INFO";
		break;

	case IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME:
		pFuncName = "IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME";
		break;
*/
	default:
		pFuncName = NULL;
		break;
	}
	
	if(pFuncName)
		KdPrint(("UsbSnoop - IRP_MJ_INTERNAL_DEVICE_CONTROL, %s\n", pFuncName));
	else
		KdPrint(("UsbSnoop - IRP_MJ_INTERNAL_DEVICE_CONTROL, unknown minor 0x%x\n", dwControlCode));

	NTSTATUS status;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);

	if(IOCTL_INTERNAL_USB_SUBMIT_URB == dwControlCode)
	{
		ULONG uSequenceNumber = InterlockedIncrement((PLONG)&pdx->uSequenceNumber);
		KdPrint(("~>>>~ URB %d going down ~>>>~\n", uSequenceNumber));
		FillRollingBuffer("~>>>~ URB %d going down ~>>>\n");
		PURB pUrb = (PURB)stack->Parameters.Others.Argument1;
		DumpURB(pUrb, FALSE);
		IoCopyCurrentIrpStackLocationToNext(Irp);
		IoSetCompletionRoutine(Irp, InternalIOCTLCompletion, (PVOID)uSequenceNumber, TRUE, TRUE, TRUE);


//		DumpIrp(Irp);
		status = IoCallDriver(pdx->LowerDeviceObject, Irp);

		// after IoCallDriver, Irp is no longer something usable
		//DumpIrp(Irp);
/// TODO - check next line with the one in the completion routine!
		IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	}
	else
	{
		IoSkipCurrentIrpStackLocation(Irp);
		status = IoCallDriver(pdx->LowerDeviceObject, Irp);
		IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	}
	
	return status;
}

/*
	DispatchPower - need a special code, since we have to call PoCallDriver()
	instead of IoCallDriver()
*/

NTSTATUS DispatchPower(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char* fcnname[] =
	{
		"IRP_MN_WAIT_WAKE",
		"IRP_MN_POWER_SEQUENCE",
		"IRP_MN_SET_POWER",
		"IRP_MN_QUERY_POWER",
	};
	
	if (fcn == IRP_MN_SET_POWER || fcn == IRP_MN_QUERY_POWER)
	{
		const char* sysstate[] =
		{
			"PowerSystemUnspecified",
			"PowerSystemWorking",
			"PowerSystemSleeping1",
			"PowerSystemSleeping2",
			"PowerSystemSleeping3",
			"PowerSystemHibernate",
			"PowerSystemShutdown",
			"PowerSystemMaximum",
		};
		
		const char* devstate[] =
		{
			"PowerDeviceUnspecified",
			"PowerDeviceD0",
			"PowerDeviceD1",
			"PowerDeviceD2",
			"PowerDeviceD3",
			"PowerDeviceMaximum",
		};
		
		ULONG context = stack->Parameters.Power.SystemContext;
		POWER_STATE_TYPE type = stack->Parameters.Power.Type;
		
		KdPrint(("UsbSnoop - IRP_MJ_POWER (%s), SystemContext %X", fcnname[fcn], context));
		if (type == SystemPowerState)
			KdPrint((", SystemPowerState = %s\n", sysstate[stack->Parameters.Power.State.SystemState]));
		else
			KdPrint((", DevicePowerState = %s\n", devstate[stack->Parameters.Power.State.DeviceState]));
	}
	else
		KdPrint(("UsbSnoop - IRP_MJ_POWER (%s)\n", fcnname[fcn]));
		
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PoStartNextPowerIrp(Irp);	// must be done while we own the IRP
	NTSTATUS status;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = PoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

NTSTATUS DispatchPnp(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char * MinorFunctionName = GetIrpPnpMinorFunctionName(fcn);
	if (MinorFunctionName != NULL)
		KdPrint(("UsbSnoop - DispatchPNP(%p) : IRP_MJ_PNP (%s)\n",
			DispatchPnp,MinorFunctionName));
	else
		KdPrint(("UsbSnoop - DispatchPNP(%p) : IRP_MJ_PNP (0x%x)\n",
			DispatchPnp,fcn));
	
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	
	if (fcn == IRP_MN_REMOVE_DEVICE)
	{
		IoReleaseRemoveLockAndWait(&pdx->RemoveLock, Irp);
		RemoveDevice(fido);
	}
	else
		IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	
	return status;
}

///////////////////////////////////////////////////////////////////////////////

NTSTATUS DispatchWmi(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{							// DispatchWmi
#if DBG
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	static char* fcnname[] = {
		"IRP_MN_QUERY_ALL_DATA",
		"IRP_MN_QUERY_SINGLE_INSTANCE",
		"IRP_MN_CHANGE_SINGLE_INSTANCE",
		"IRP_MN_CHANGE_SINGLE_ITEM",
		"IRP_MN_ENABLE_EVENTS",
		"IRP_MN_DISABLE_EVENTS",
		"IRP_MN_ENABLE_COLLECTION",
		"IRP_MN_DISABLE_COLLECTION",
		"IRP_MN_REGINFO",
		"IRP_MN_EXECUTE_METHOD",
	};
	
	KdPrint(("UsbSnoop - IRP_MJ_SYSTEM_CONTROL (%s)\n", fcnname[fcn]));
#endif // DBG
	
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma PAGEDCODE

VOID RemoveDevice(IN PDEVICE_OBJECT fido)
{
	PAGED_CODE();
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;

	KdPrint(("UsbSnoop - RemoveDevice(%p) : fido = %p\n",RemoveDevice,fido));
	
	if (pdx->LowerDeviceObject)
	{
		// save our modified PDRIVER_OBJECT
		PDRIVER_OBJECT d = pdx->LowerDeviceObject->DriverObject;

		// restore the driver pointer in the PDO
		pdx->LowerDeviceObject->DriverObject = pdx->OriginalDriverObject;

		IoDetachDevice(pdx->LowerDeviceObject);

		// free our modified PDRIVER_OBJECT
		ExFreePool(d);
	}

	IoDeleteDevice(fido);
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE

extern "C" void __declspec(naked) __cdecl _chkesp()
{
	_asm je okay
	ASSERT(!"Stack pointer mismatch!");
okay:
	_asm ret
}
=======
// Main program for UsbSnoop driver
// Generated by Walt Oney's driver wizard

#include "stddcls.h"
#include "driver.h"
#include "usbioctl.h"

NTSTATUS AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT pdo);
VOID DriverUnload(IN PDRIVER_OBJECT fido);
NTSTATUS DispatchAny(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchPower(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchPnp(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchWmi(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchInternalIOCTL(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS MyDispatchInternalIOCTL(IN PDEVICE_OBJECT fido, IN PIRP Irp);
void DumpURB(PURB pUrb, BOOLEAN bReturnedFromHCD);

BOOLEAN win98 = FALSE;
UNICODE_STRING servkey;
HANDLE fileHandle = (HANDLE)NULL;
KSEMAPHORE DataToBeRead;
//PWORK_QUEUE_ITEM BottomHalf;
HANDLE ThreadHandle;



// functions to handle conversion from PipeHandle to endpint number

struct ENDPOINT_INFO 
{
    USBD_PIPE_HANDLE PipeHandle;
	unsigned char    Endpoint;
};

struct ENDPOINT_INFO TabEndpointInfo[10] =
{
	{ NULL, 0 },
};

bool GetEndpointInfo(USBD_PIPE_HANDLE inPipeHandle, unsigned char * outEndpoint)
{
	for (int i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle != NULL 
			&& TabEndpointInfo[i].PipeHandle == inPipeHandle)
		{
			*outEndpoint = TabEndpointInfo[i].Endpoint;
			return true;
		}
	}

	return false;
}


//		Jean-Sébastien Valette
//
//		Write To LogFile
//
//		26 08 2001
//
//		09 09 2001 change to be a thread
//

VOID LogToFile(PVOID Parameter)
{
	char *test = "Test\n";
	NTSTATUS status;
	IO_STATUS_BLOCK ioStatusBlock;
	OBJECT_ATTRIBUTES objectAttributes;
	UNICODE_STRING unicodeObjectName;
	ANSI_STRING ansiObjectName;
	char *version="UsbSnoop compiled on " __DATE__ " " __TIME__ "\n";

	status = ZwWriteFile(&fileHandle,NULL,NULL,NULL,&ioStatusBlock,
			(PVOID) test,strlen(test),0,0);
	if(status != STATUS_SUCCESS )
	{
		KdPrint(("LogToFile can't write into Logfile, status = %x\n",status));
		KdPrint(("fileHandle : %x\n",fileHandle));
	}
	
	//	Jean-Sébastien Valette 08 09 2001
	//
	//	try to open a log File

	RtlInitAnsiString(&ansiObjectName,"\\SystemRoot\\snoopy.log");
 	status = RtlAnsiStringToUnicodeString(&unicodeObjectName,&ansiObjectName,TRUE);
	if (status != STATUS_SUCCESS)
 		KdPrint(("RtlAnsiStringToUnicodeString failed, status = 0x%xx\n",status));
	InitializeObjectAttributes(&objectAttributes,&unicodeObjectName,0,NULL,NULL);


 
 	status = ZwCreateFile(&fileHandle,FILE_WRITE_DATA|SYNCHRONIZE ,
	 	&objectAttributes,&ioStatusBlock,NULL,FILE_ATTRIBUTE_NORMAL,FILE_SHARE_READ,
	FILE_OPEN_IF,FILE_SYNCHRONOUS_IO_NONALERT,NULL,0);
 	if (status != STATUS_SUCCESS)
 		KdPrint(("ZwCreateFile failed, status = 0x%x\n",status));
	else
		KdPrint(("\n\nusbsnoop: File Opened\nusbsnoop: fileHandle = %x\n",
			fileHandle));

	status = ZwWriteFile(fileHandle,NULL,NULL,NULL,&ioStatusBlock,version,
				(unsigned long)strlen(version),NULL,NULL);
	if(status != STATUS_SUCCESS )
	{
		KdPrint(("Can't write into Logfile, status = %x\n",status));
		ZwClose(fileHandle);
	}


	ZwClose(fileHandle);
	
	
	return;	
};




void AddEndpointInfo(USBD_PIPE_HANDLE inPipeHandle, unsigned char inEndpoint)
{
	int i;

	// search for an existing PipeHandle
	for (i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle != NULL 
			&& TabEndpointInfo[i].PipeHandle == inPipeHandle)
			return ; 
	}

	// search for a free slot 
	for (i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle == NULL)
		{
			TabEndpointInfo[i].PipeHandle = inPipeHandle;
			TabEndpointInfo[i].Endpoint = inEndpoint;
			return ;
		}
	}

	KdPrint(("AddEndpointInfo failed!\n"));
}



///////////////////////////////////////////////////////////////////////////////

void DumpStackLocation(PIO_STACK_LOCATION stack)
{
	if (stack == NULL)
		return ;

	KdPrint(("    MajorFunction=%d, MinorFunction=%d\n",
		stack->MajorFunction,stack->MinorFunction));
	KdPrint(("    DeviceObject=%p\n",stack->DeviceObject));
	KdPrint(("    CompletionRoutine=%p Context=%p\n",stack->CompletionRoutine,stack->Context));

}

void DumpIrp(PIRP Irp)
{
	KdPrint(("Dumping IRP %p\n",Irp));
	if (Irp==NULL)
		return ;

	KdPrint(("  Type=%d, Size=%d\n",Irp->Type,Irp->Size));
	KdPrint(("  StackCount=%d, CurrentLocation=%d\n",Irp->StackCount,Irp->CurrentLocation));
	for (CHAR i=0;i<Irp->StackCount;i++)
	{
		PIO_STACK_LOCATION stack = (PIO_STACK_LOCATION) (Irp+1) + i;
		KdPrint(("  [%d] MajorFunction=%d, MinorFunction=%d, DeviceObject=%p\n",
			i,stack->MajorFunction,stack->MinorFunction,stack->DeviceObject));
		KdPrint(("      Arg1=%p, Arg2=%p, Arg3=%p, Arg4=%p\n",
			stack->Parameters.Others.Argument1,stack->Parameters.Others.Argument2,
			stack->Parameters.Others.Argument3,stack->Parameters.Others.Argument4));
		KdPrint(("      CompletionRoutine=%p Context=%p\n",
			stack->CompletionRoutine,stack->Context));
	}
}

void DumpDriverObject(PDRIVER_OBJECT p)
{
	KdPrint(("UsbSnoop - DumpDriverObject : p = %p\n",p));
	KdPrint(("  Type = %d\n",p->Type));
	KdPrint(("  Size = %d\n",p->Size));
	KdPrint(("  DeviceObject = %p\n",p->DeviceObject));
	KdPrint(("  Flags = 0x%x\n",p->Flags));
	KdPrint(("  DriverStart = %p\n",p->DriverStart));
	KdPrint(("  DriverSize = %d\n",p->DriverSize));
	KdPrint(("  DriverSection = %p\n",p->DriverSection));
	KdPrint(("  DriverExtension = %p\n",p->DriverExtension));
	KdPrint(("  DriverExtension->AddDevice = %p\n",p->DriverExtension->AddDevice));
	KdPrint(("  FastIoDispatch = %p\n",p->FastIoDispatch));
	KdPrint(("  DriverInit = %p\n",p->DriverInit));
	KdPrint(("  DriverStartIo = %p\n",p->DriverStartIo));
	KdPrint(("  DriverUnload = %p\n",p->DriverUnload));
	for (int i=0;i<IRP_MJ_MAXIMUM_FUNCTION + 1;i++)
		KdPrint(("  MajorFunction[%d] = %p\n",i,p->MajorFunction[i]));
}

void DumpDeviceObject(PDEVICE_OBJECT p)
{
	KdPrint(("UsbSnoop - DumpDeviceObject : p = %p\n",p));
	KdPrint(("  DriverObject = %p\n",p->DriverObject));
	KdPrint(("  NextDevice = %p\n",p->NextDevice));
	KdPrint(("  AttachedDevice = %p\n",p->AttachedDevice));
	KdPrint(("  StackSize=%d\n",p->StackSize));
	KdPrint(("  CurrentIrp = %p\n",p->CurrentIrp));
	KdPrint(("  DeviceObjectExtension = %p\n",p->DeviceObjectExtension));

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)p->DeviceObjectExtension;

	KdPrint(("   ->DeviceObject=%p\n",pdx->DeviceObject));
	KdPrint(("   ->LowerDeviceObject=%p\n",pdx->LowerDeviceObject));
	KdPrint(("   ->Pdo=%p\n",pdx->Pdo));
}

void DumpContext(PCONTEXT Context)
{
	KdPrint(("DumpContext : Context=%p\n",Context));
	KdPrint(("  CompletionRoutine=%p, Context=%p, Control=%x\n",
		Context->CompletionRoutine,Context->Context,Context->Control));
	KdPrint(("  pUrb=%p, uSequenceNumber=%d, Stack=%p\n",
		Context->pUrb,Context->uSequenceNumber,Context->Stack));
}

#pragma INITCODE

/*
	DriverEntry : this function is called whenever this driver is loaded in memory,
		this is the only entry point this is accessible for the OS. Other entry
		points will be set up inside DriverEntry().
*/

extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	UCHAR MajorVersion, MinorVersion;

	//	Jean-Sebastien Vallette 25 08 2001
	//	Decaration for log file
	NTSTATUS status;
	LARGE_INTEGER ByteOffset;
	


	KdPrint(("UsbSnoop compiled on " __DATE__ " " __TIME__ "\n"));
	// Valette Jean-Sébastien
	//
	//	LogThread initialisation
	//
	//	Added 09 09 2001
	status = PsCreateSystemThread( &ThreadHandle,THREAD_ALL_ACCESS ,0,
					0,0, LogToFile,0);

	//	Valette Jean-Sébastien 
	//
	//	Initialize Semaphore
	//
	//	Added 09 09 2001
	KeInitializeSemaphore(&DataToBeRead,0,1);



	ByteOffset.QuadPart = FILE_USE_FILE_POINTER_POSITION;
	
	// Insist that OS support at least the WDM 1.0 (Win98 DDK)
	
	if (!IoIsWdmVersionAvailable(1, 0))
	{
		KdPrint(("UsbSnoop - Expected version of WDM (%d.%2.2d) not available\n", 1, 0));
		return STATUS_UNSUCCESSFUL;
	}
	
	// See if we're running under Win98 or NT:
	
	win98 = !IoIsWdmVersionAvailable(1, 10); //DriverObject->DriverExtension->ServiceKeyName.Length == 0;
	
	MajorVersion = 0;
	MinorVersion = 0;

	while (IoIsWdmVersionAvailable(MajorVersion,MinorVersion))
		MajorVersion ++;

	MajorVersion --;

	while (IoIsWdmVersionAvailable(MajorVersion,MinorVersion))
		MinorVersion ++;
	MinorVersion --;

	if (win98)
		KdPrint(("UsbSnoop - DriverEntry(%p) : Windows 98 WDM version %d.%d\n",
			DriverEntry,MajorVersion,MinorVersion));
	else
		KdPrint(("UsbSnoop - DriverEntry(%p) : Windows NT WDM version %d.%d\n",
			DriverEntry,MajorVersion,MinorVersion));

//	DumpDriverObject(DriverObject);

	// Save the name of the service key

	servkey.Buffer = (PWSTR) ExAllocatePool(PagedPool, RegistryPath->MaximumLength);
	if (!servkey.Buffer)
	{
		KdPrint(("UsbSnoop - Unable to allocate %d bytes for copy of service key name\n", RegistryPath->MaximumLength));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	servkey.MaximumLength = RegistryPath->MaximumLength;
	RtlCopyUnicodeString(&servkey, RegistryPath);

	// Initialize function pointers

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->DriverExtension->AddDevice = AddDevice;
	
	for (int i = 0; i < arraysize(DriverObject->MajorFunction); ++i)
		DriverObject->MajorFunction[i] = DispatchAny;

	// POWER IRP needs a special treatment
	DriverObject->MajorFunction[IRP_MJ_POWER] = DispatchPower;

	// we need a special callback to call RemoveDevice().
	// this is now done in MyDispatchPnp
//	DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;

	// not needed
//	DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = DispatchWmi;

	// not needed
//	DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = DispatchInternalIOCTL;

//	DumpDriverObject(DriverObject);

	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////

#pragma PAGEDCODE

/*
	DriverUnload() is called whenever our driver is unloaded from memory.
*/

VOID DriverUnload(IN PDRIVER_OBJECT DriverObject)
{
	NTSTATUS status;
	PAGED_CODE();
	KdPrint(("UsbSnoop - DriverUnload(%p) : DriverObject %p\n",
		DriverUnload,DriverObject));
//	DumpDriverObject(DriverObject);
	RtlFreeUnicodeString(&servkey);
	//	Jean-Seabstien Valette
//
//	Added freein of ressource need by log to file

//	ExFreePool(BottomHalf);
       
	status = ZwClose(fileHandle);
	KdPrint(("usbsnoop : Closed File \n"));
	KdPrint(("usbsnoop: status %x\n",status));

}

const char * GetIrpPnpMinorFunctionName(ULONG fcn)
{
	static const char* fcnname[] =
	{
		"IRP_MN_START_DEVICE",
		"IRP_MN_QUERY_REMOVE_DEVICE",
		"IRP_MN_REMOVE_DEVICE",
		"IRP_MN_CANCEL_REMOVE_DEVICE",
		"IRP_MN_STOP_DEVICE",
		"IRP_MN_QUERY_STOP_DEVICE",
		"IRP_MN_CANCEL_STOP_DEVICE",
		"IRP_MN_QUERY_DEVICE_RELATIONS",
		"IRP_MN_QUERY_INTERFACE",
		"IRP_MN_QUERY_CAPABILITIES",
		"IRP_MN_QUERY_RESOURCES",
		"IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
		"IRP_MN_QUERY_DEVICE_TEXT",
		"IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
		"",
		"IRP_MN_READ_CONFIG",
		"IRP_MN_WRITE_CONFIG",
		"IRP_MN_EJECT",
		"IRP_MN_SET_LOCK",
		"IRP_MN_QUERY_ID",
		"IRP_MN_QUERY_PNP_DEVICE_STATE",
		"IRP_MN_QUERY_BUS_INFORMATION",
		"IRP_MN_DEVICE_USAGE_NOTIFICATION",
		"IRP_MN_SURPRISE_REMOVAL",
	};

	if (0<=fcn && fcn<arraysize(fcnname))
		return fcnname[fcn];

	return NULL;
}

NTSTATUS MyDispatchPnp(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char * MinorFunctionName = GetIrpPnpMinorFunctionName(fcn);
	if (MinorFunctionName != NULL)
		KdPrint(("UsbSnoop - MyDispatchPNP(%p) : IRP_MJ_PNP (%s)\n",
			MyDispatchPnp,MinorFunctionName));
	else
		KdPrint(("UsbSnoop - MyDispatchPNP(%p) : IRP_MJ_PNP (0x%x)\n",
			MyDispatchPnp,fcn));
	
	PDEVICE_OBJECT fido = fdo->AttachedDevice;
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;

	status = pdx->OriginalDriverObject->MajorFunction[IRP_MJ_PNP](fdo,Irp);	

	// the following lines should be executed ONLY if DispatchPNP() callback
	// is not used, since it duplicates its work.

	if (fcn == IRP_MN_REMOVE_DEVICE)
		RemoveDevice(fido);
	
	return status;
}

/*
	AddDevice is called for each device we have to managed. This is where we
	get the oportunity to be added in the device object stack.
*/

NTSTATUS AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT pdo)
{
	PAGED_CODE();
	KdPrint(("UsbSnoop - AddDevice(%p) : DriverObject %p, pdo %p\n",
		AddDevice,DriverObject, pdo));

//	DumpDriverObject(DriverObject);
//	DumpDeviceObject(pdo);


	NTSTATUS status;
	
	// Create a UsbSnoop device object to represent the hardware we're managing.
	
	PDEVICE_OBJECT fido;

	status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),NULL,
		FILE_DEVICE_UNKNOWN, 0, FALSE, &fido);
	if (!NT_SUCCESS(status))
	{						// can't create device object
		KdPrint(("UsbSnoop - IoCreateDevice failed - %X\n", status));
		return status;
	}						// can't create device object

	// Benoit PAPILLAULT 13/07/2001
	// fido->DeviceExtension is a user define structure whose size is passed
	// to IoCreateDevice(). We can store whatever we want inside.

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	
	// From this point forward, any error will have side effects that need to
	// be cleaned up. Using a try-finally block allows us to modify the program
	// easily without losing track of the side effects.
	
	__try
	{						// finish initialization
		IoInitializeRemoveLock(&pdx->RemoveLock, 0, 0, 255);
		pdx->DeviceObject = fido;
		pdx->Pdo = pdo;
		
		// Add our device object to the stack and propagate critical settings
		// from the immediately lower device object
		
		PDEVICE_OBJECT fdo = IoAttachDeviceToDeviceStack(fido, pdo);

		pdx->LowerDeviceObject = fdo;
		fido->Flags |= fdo->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE | DO_POWER_INRUSH);
		fido->DeviceType = fdo->DeviceType;
		fido->Characteristics = fdo->Characteristics;
		fido->AlignmentRequirement = fdo->AlignmentRequirement;
		
		// Clear the "initializing" flag so that we can get IRPs
		
		fido->Flags &= ~DO_DEVICE_INITIALIZING;

//		DumpDriverObject(DriverObject);
//		DumpDeviceObject(fdo);
//		DumpDeviceObject(fido);
//		DumpDeviceObject(pdo);

		// we make a copy of fdo->DriverObject
		PDRIVER_OBJECT d = (PDRIVER_OBJECT)ExAllocatePool(PagedPool,sizeof(DRIVER_OBJECT));
		if (d != NULL)
		{
			*d = *fdo->DriverObject;

			// we make some changes to this copy
			d->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = MyDispatchInternalIOCTL;
			d->MajorFunction[IRP_MJ_PNP]                     = MyDispatchPnp;

			// here is the trick : we save the original DriverObject
			// and next, it points to our modified copy
			pdx->OriginalDriverObject = fdo->DriverObject;
			fdo->DriverObject = d;

			KdPrint(("  OriginalDriverObject = %p\n",pdx->OriginalDriverObject));
		}
		else
			KdPrint(("ExAllocatePool failed : not redirecting PDO->DriverObject\n"));
	}						// finish initialization
	__finally
	{						// cleanup side effects
		if (!NT_SUCCESS(status))
		{					// need to cleanup
			IoDeleteDevice(fido);
		}					// need to cleanup
	}						// cleanup side effects
	
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE

NTSTATUS CompleteRequest(IN PIRP Irp, IN NTSTATUS status, IN ULONG info)
{
	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = info;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE				// make no assumptions about pageability of dispatch fcns

NTSTATUS DispatchAny(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	
	const char* irpname[] =
	{
		"IRP_MJ_CREATE",
		"IRP_MJ_CREATE_NAMED_PIPE",
		"IRP_MJ_CLOSE",
		"IRP_MJ_READ",
		"IRP_MJ_WRITE",
		"IRP_MJ_QUERY_INFORMATION",
		"IRP_MJ_SET_INFORMATION",
		"IRP_MJ_QUERY_EA",
		"IRP_MJ_SET_EA",
		"IRP_MJ_FLUSH_BUFFERS",
		"IRP_MJ_QUERY_VOLUME_INFORMATION",
		"IRP_MJ_SET_VOLUME_INFORMATION",
		"IRP_MJ_DIRECTORY_CONTROL",
		"IRP_MJ_FILE_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CONTROL",
		"IRP_MJ_INTERNAL_DEVICE_CONTROL",
		"IRP_MJ_SHUTDOWN",
		"IRP_MJ_LOCK_CONTROL",
		"IRP_MJ_CLEANUP",
		"IRP_MJ_CREATE_MAILSLOT",
		"IRP_MJ_QUERY_SECURITY",
		"IRP_MJ_SET_SECURITY",
		"IRP_MJ_POWER",
		"IRP_MJ_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CHANGE",
		"IRP_MJ_QUERY_QUOTA",
		"IRP_MJ_SET_QUOTA",
		"IRP_MJ_PNP",
	};
	
	UCHAR type = stack->MajorFunction;
	if (type >= arraysize(irpname))
		KdPrint(("UsbSnoop - DispatchAny : Unknown IRP, MajorFunction=0x%x\n", type));
	else
		KdPrint(("UsbSnoop - DispatchAny : %s\n", irpname[type]));
	
	// Pass request down without additional processing
	
	NTSTATUS status;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

void DumpBuffer(unsigned char * buf, int len)
{
#define NB_BYTE 16 /* number of bytes displayed per line */

	char str[NB_BYTE*3 + 1];

	for (int i=0;i<len;i+=NB_BYTE)
	{
		char * p = str;

		for (int j=i;j<len&&j<i+NB_BYTE;j++)
		{
			char c;

			*p++ = ' ';
			c = (buf[j] >> 4) & 0xf;
			*p++ = (c<10) ? c+'0' : c-10+'a';
			c = buf[j] & 0xf;
			*p++ = (c<10) ? c+'0' : c-10+'a';
		}
		*p = 0;

		KdPrint(("    %04x:%s\n",i,str));
	}
}

void DumpTransferBuffer(PUCHAR pBuffer, PMDL pMdl, ULONG uBufferSize, BOOLEAN bPrintHeader)
{
	if(bPrintHeader)
	{
		KdPrint(("  TransferBufferLength = %08x\n", uBufferSize));
		KdPrint(("  TransferBuffer       = %08x\n", pBuffer));
		KdPrint(("  TransferBufferMDL    = %08x\n", pMdl));
	}
	else
	{
		if(pBuffer)
		{
			if(pMdl)
			{
				//KdPrint(("??? weird transfer buffer, both MDL and flat specified. Ignoring MDL\n"));
			}
			DumpBuffer(pBuffer,uBufferSize);
		}
		else if(pMdl)
		{
			PUCHAR pMDLBuf = (PUCHAR)MmGetSystemAddressForMdl(pMdl);
			if(pMDLBuf)
				DumpBuffer(pMDLBuf,uBufferSize);
			else
			{
				KdPrint(("XXXXX ERROR: can't map MDL!\n"));
			}
		}
		else
		{
			KdPrint(("\n    no data supplied\n"));
		}
	}
}

void DumpGetStatusRequest(struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusRequest, BOOLEAN bReturnedFromHCD)
{
	DumpTransferBuffer((PUCHAR)pGetStatusRequest->TransferBuffer, pGetStatusRequest->TransferBufferMDL, pGetStatusRequest->TransferBufferLength, TRUE);
	if(pGetStatusRequest->TransferBufferLength != 1)
		KdPrint(("  *** error - TransferBufferLength should be 1!\n"));
	if(bReturnedFromHCD)
	{
		DumpTransferBuffer((PUCHAR)pGetStatusRequest->TransferBuffer, pGetStatusRequest->TransferBufferMDL, pGetStatusRequest->TransferBufferLength, FALSE);
	}

	KdPrint(("  Index                = %02x\n", pGetStatusRequest->Index));
	
	if(pGetStatusRequest->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pGetStatusRequest->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}
}

void DumpFeatureRequest(struct _URB_CONTROL_FEATURE_REQUEST *pFeatureRequest, BOOLEAN bReadFromDevice, BOOLEAN bReturnedFromHCD)
{
	KdPrint(("  FeatureSelector = %04x\n", pFeatureRequest->FeatureSelector));
	KdPrint(("  Index           = %04x\n", pFeatureRequest->Index));
	if(pFeatureRequest->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pFeatureRequest->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}
}

void DumpDescriptorRequest(struct _URB_CONTROL_DESCRIPTOR_REQUEST *pDescriptorRequest, BOOLEAN bReadFromDevice, BOOLEAN bReturnedFromHCD)
{
	DumpTransferBuffer((PUCHAR)pDescriptorRequest->TransferBuffer, pDescriptorRequest->TransferBufferMDL, pDescriptorRequest->TransferBufferLength, TRUE);
	if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
	{
		DumpTransferBuffer((PUCHAR)pDescriptorRequest->TransferBuffer, pDescriptorRequest->TransferBufferMDL, pDescriptorRequest->TransferBufferLength, FALSE);
	}

	KdPrint(("  Index                = %02x\n", pDescriptorRequest->Index));
	KdPrint(("  DescriptorType       = %02x (%s)\n", pDescriptorRequest->DescriptorType,
		pDescriptorRequest->DescriptorType == USB_DEVICE_DESCRIPTOR_TYPE ? "USB_DEVICE_DESCRIPTOR_TYPE" :
		pDescriptorRequest->DescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE ? "USB_CONFIGURATION_DESCRIPTOR_TYPE" :
		pDescriptorRequest->DescriptorType == USB_STRING_DESCRIPTOR_TYPE ? "USB_STRING_DESCRIPTOR_TYPE" : "<illegal descriptor type!>"));
	KdPrint(("  LanguageId           = %04x\n", pDescriptorRequest->LanguageId));
	
	if(pDescriptorRequest->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pDescriptorRequest->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}
}

void DumpVendorOrClassRequest(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassInterface, BOOLEAN bReturnedFromHCD)
{
	BOOLEAN bReadFromDevice = (BOOLEAN)(pFunctionClassInterface->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
	KdPrint(("  TransferFlags          = %08x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pFunctionClassInterface->TransferFlags,
		bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
		pFunctionClassInterface->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~"));

	DumpTransferBuffer((PUCHAR)pFunctionClassInterface->TransferBuffer, pFunctionClassInterface->TransferBufferMDL, pFunctionClassInterface->TransferBufferLength, TRUE);
	if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
	{
		DumpTransferBuffer((PUCHAR)pFunctionClassInterface->TransferBuffer, pFunctionClassInterface->TransferBufferMDL, pFunctionClassInterface->TransferBufferLength, FALSE);
	}

	KdPrint(("  UrbLink                 = %08x\n", pFunctionClassInterface->UrbLink));
	KdPrint(("  RequestTypeReservedBits = %02x\n", pFunctionClassInterface->RequestTypeReservedBits));
	KdPrint(("  Request                 = %02x\n", pFunctionClassInterface->Request));
	KdPrint(("  Value                   = %04x\n", pFunctionClassInterface->Value));
	KdPrint(("  Index                   = %04x\n", pFunctionClassInterface->Index));
	if(pFunctionClassInterface->UrbLink)
	{
		KdPrint(("---> Linked URB:\n"));
		DumpURB(pFunctionClassInterface->UrbLink, bReturnedFromHCD);
		KdPrint(("---< Linked URB\n"));
	}

}

void DumpPipeHandle(const char *s,USBD_PIPE_HANDLE inPipeHandle)
{
	unsigned char ep;

	// search for the matching endpoint

	if (GetEndpointInfo(inPipeHandle,&ep))
		KdPrint(("%s = %p [endpoint 0x%x]\n",s,inPipeHandle,ep));
	else
		KdPrint(("%s = %p\n",s,inPipeHandle));
}

void DumpURB(PURB pUrb, BOOLEAN bReturnedFromHCD)
{
	if(NULL == pUrb)
	{
		KdPrint(("UsbSnoop - URB == NULL ???\n"));
		return;
	}

	USHORT wFunction = pUrb->UrbHeader.Function;
	USHORT wLength = pUrb->UrbHeader.Length;
	USBD_STATUS lUsbdStatus = pUrb->UrbHeader.Status;

	/* Status values are defined in <usbdi.h> as USBD_STATUS_XXX */
//	KdPrint(("  Header.Length = %d\n",          pUrb->UrbHeader.Length));
//	KdPrint(("  Header.Function = 0x%x\n",      pUrb->UrbHeader.Function));
//	KdPrint(("  Header.Status = 0x%x\n",        pUrb->UrbHeader.Status));
//	KdPrint(("  Header.UsbdDeviceHandle = %p\n",pUrb->UrbHeader.UsbdDeviceHandle));
//	KdPrint(("  Header.UsbdFlags = 0x%x\n",     pUrb->UrbHeader.UsbdFlags));

	switch(wFunction)
	{
	case URB_FUNCTION_SELECT_CONFIGURATION:
		{

			/* _URB_SELECT_CONFIGURATION is as follows :

			- a first block of 16 bytes : struct _URB_HEADER Hdr
			- a pointer (4 byes) : PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
			      this can be a NULL pointer, in which case the array of USBD_INTERFACE_INFORMATION
				  is empty.
			- a handle (4 bytes) : USBD_CONFIGURATION_HANDLE ConfigurationHandle
			- an array of USBD_INTERFACE_INFORMATION, whose number are
			    ConfigurationDescriptor.bNumInterfaces

			each USBD_INTERFACE_INFORMATION contains fixed information (16 bytes), followed
			  by an array of USB_PIPE_INFORMATION (20 bytes) whose number is NumberOfPipes.
			*/

#define URB_SELECT_CONFIGURATION_SIZE 24

			struct _URB_SELECT_CONFIGURATION *pSelectConfiguration = (struct _URB_SELECT_CONFIGURATION*) pUrb;
			KdPrint(("-- URB_FUNCTION_SELECT_CONFIGURATION:\n"));
			if(pSelectConfiguration->Hdr.Length < URB_SELECT_CONFIGURATION_SIZE)
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
					pSelectConfiguration->Hdr.Length,URB_SELECT_CONFIGURATION_SIZE));

			PUSB_CONFIGURATION_DESCRIPTOR pCD = pSelectConfiguration->ConfigurationDescriptor;
			KdPrint(("  ConfigurationDescriptor = 0x%x %s\n",pCD,pCD ? "(configure)":"(unconfigure)"));
			if (pCD == NULL)
				break;

			KdPrint(("  ConfigurationDescriptor : bLength             = %d\n", pCD->bLength));
			KdPrint(("  ConfigurationDescriptor : bDescriptorType     = 0x%02x\n", pCD->bDescriptorType));
			KdPrint(("  ConfigurationDescriptor : wTotalLength        = 0x%04x\n", pCD->wTotalLength));
			KdPrint(("  ConfigurationDescriptor : bNumInterfaces      = 0x%02x\n", pCD->bNumInterfaces));
			KdPrint(("  ConfigurationDescriptor : bConfigurationValue = 0x%02x\n", pCD->bConfigurationValue));
			KdPrint(("  ConfigurationDescriptor : iConfiguration      = 0x%02x\n", pCD->iConfiguration));
			KdPrint(("  ConfigurationDescriptor : bmAttributes        = 0x%02x\n", pCD->bmAttributes));
			KdPrint(("  ConfigurationDescriptor : MaxPower            = 0x%02x\n", pCD->MaxPower));
			KdPrint(("  ConfigurationHandle     = 0x%08x\n", pSelectConfiguration->ConfigurationHandle));
			
			ULONG uNumInterfaces = pCD->bNumInterfaces;

			if(uNumInterfaces > 0xff)
			{
				KdPrint(("XXXXXX ERROR: uNumInterfaces is too large (%d), resetting to 1\n", uNumInterfaces));
				uNumInterfaces = 1;
			}
			
			
			PUSBD_INTERFACE_INFORMATION pInterface = &pSelectConfiguration->Interface;
			for(ULONG i = 0; i < uNumInterfaces; i++)
			{
				KdPrint(("  Interface[%d]: Length            = %d\n", i, pInterface->Length));
				KdPrint(("  Interface[%d]: InterfaceNumber   = %d\n", i, pInterface->InterfaceNumber));
				KdPrint(("  Interface[%d]: AlternateSetting  = %d\n", i, pInterface->AlternateSetting));
				if(bReturnedFromHCD)
				{
					ULONG uNumPipes;
					KdPrint(("  Interface[%d]: Class             = 0x%02x\n", i, pInterface->Class));
					KdPrint(("  Interface[%d]: SubClass          = 0x%02x\n", i, pInterface->SubClass));
					KdPrint(("  Interface[%d]: Protocol          = 0x%02x\n", i, pInterface->Protocol));
					KdPrint(("  Interface[%d]: InterfaceHandle   = 0x%08x\n", i, pInterface->InterfaceHandle));
					KdPrint(("  Interface[%d]: NumberOfPipes     = %d\n", i, pInterface->NumberOfPipes));
					
					uNumPipes = pInterface->NumberOfPipes;
					if(uNumPipes > 0x1f)
					{
						KdPrint(("XXXXXX ERROR: uNumPipes is too large (%d), resetting to 1\n", uNumPipes));
						uNumPipes = 1;
					}
					for(ULONG p = 0; p< uNumPipes; p++)
					{
						KdPrint(("  Interface[%d]: Pipes[%lu] : MaximumPacketSize = 0x%04x\n", i, p, pInterface->Pipes[p].MaximumPacketSize));
						KdPrint(("  Interface[%d]: Pipes[%lu] : EndpointAddress   = 0x%02x\n", i, p, pInterface->Pipes[p].EndpointAddress));
						KdPrint(("  Interface[%d]: Pipes[%lu] : Interval          = 0x%02x\n", i, p, pInterface->Pipes[p].Interval));
						KdPrint(("  Interface[%d]: Pipes[%lu] : PipeType          = 0x%02x (%s)\n", i, p, pInterface->Pipes[p].PipeType,
							pInterface->Pipes[p].PipeType == UsbdPipeTypeControl ? "UsbdPipeTypeControl" :
						pInterface->Pipes[p].PipeType == UsbdPipeTypeIsochronous ? "UsbdPipeTypeIsochronous" :
						pInterface->Pipes[p].PipeType == UsbdPipeTypeBulk ? "UsbdPipeTypeBulk" :
						pInterface->Pipes[p].PipeType == UsbdPipeTypeInterrupt ? "UsbdPipeTypeInterrupt" : "!!! INVALID !!!"
							));
						KdPrint(("  Interface[%d]: Pipes[%lu] : PipeHandle        = 0x%p\n", i, p, pInterface->Pipes[p].PipeHandle));
						KdPrint(("  Interface[%d]: Pipes[%lu] : MaxTransferSize   = 0x%08x\n", i, p, pInterface->Pipes[p].MaximumTransferSize));
						KdPrint(("  Interface[%d]: Pipes[%lu] : PipeFlags         = 0x%02x\n", i, p, pInterface->Pipes[p].PipeFlags));

						AddEndpointInfo(pInterface->Pipes[p].PipeHandle,
							pInterface->Pipes[p].EndpointAddress);
					}
				}

				pInterface = (PUSBD_INTERFACE_INFORMATION) (((UCHAR*)pInterface) + pInterface->Length);
			}
		}
		break;

	case URB_FUNCTION_SELECT_INTERFACE:
		{
			struct _URB_SELECT_INTERFACE  *pSelectInterface = (struct _URB_SELECT_INTERFACE *) pUrb;

			KdPrint(("-- URB_FUNCTION_SELECT_INTERFACE:\n"));
			if(pSelectInterface->Hdr.Length < sizeof(struct _URB_SELECT_INTERFACE))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSelectInterface->Hdr.Length, sizeof(struct _URB_SELECT_INTERFACE)));
			KdPrint(("  ConfigurationHandle     = 0x%08x\n", pSelectInterface->ConfigurationHandle));

			PUSBD_INTERFACE_INFORMATION pInterface = &pSelectInterface->Interface;
			
			KdPrint(("  Interface: Length            = %d\n", pInterface->Length));
			KdPrint(("  Interface: InterfaceNumber   = %d\n", pInterface->InterfaceNumber));
			KdPrint(("  Interface: AlternateSetting  = %d\n", pInterface->AlternateSetting));
			KdPrint(("  Interface: Class             = 0x%02x\n", pInterface->Class));
			KdPrint(("  Interface: SubClass          = 0x%02x\n", pInterface->SubClass));
			KdPrint(("  Interface: Protocol          = 0x%02x\n", pInterface->Protocol));
			KdPrint(("  Interface: InterfaceHandle   = %p\n", pInterface->InterfaceHandle));
			KdPrint(("  Interface: NumberOfPipes     = %d\n", pInterface->NumberOfPipes));
			if(bReturnedFromHCD)
			{
				ULONG uNumPipes = pInterface->NumberOfPipes;
				if(uNumPipes > 0x1f)
				{
					KdPrint(("XXXXXX ERROR: uNumPipes is too large (%d), resetting to 1\n", uNumPipes));
					uNumPipes = 1;
				}
				for(ULONG p = 0; p< uNumPipes; p++)
				{
					KdPrint(("  Interface: Pipes[%lu] : MaximumPacketSize = 0x%04x\n", p, pInterface->Pipes[p].MaximumPacketSize));
					KdPrint(("  Interface: Pipes[%lu] : EndpointAddress   = 0x%02x\n", p, pInterface->Pipes[p].EndpointAddress));
					KdPrint(("  Interface: Pipes[%lu] : Interval          = 0x%02x\n", p, pInterface->Pipes[p].Interval));
					KdPrint(("  Interface: Pipes[%lu] : PipeType          = 0x%02x (%s)\n", p, pInterface->Pipes[p].PipeType,
						pInterface->Pipes[p].PipeType == UsbdPipeTypeControl ? "UsbdPipeTypeControl" :
					pInterface->Pipes[p].PipeType == UsbdPipeTypeIsochronous ? "UsbdPipeTypeIsochronous" :
					pInterface->Pipes[p].PipeType == UsbdPipeTypeBulk ? "UsbdPipeTypeBulk" :
					pInterface->Pipes[p].PipeType == UsbdPipeTypeInterrupt ? "UsbdPipeTypeInterrupt" : "!!! INVALID !!!"
						));
					KdPrint(("  Interface: Pipes[%lu] : PipeHandle        = 0x%p\n", p, pInterface->Pipes[p].PipeHandle));
					KdPrint(("  Interface: Pipes[%lu] : MaxTransferSize   = 0x%08x\n", p, pInterface->Pipes[p].MaximumTransferSize));
					KdPrint(("  Interface: Pipes[%lu] : PipeFlags         = 0x%02x\n", p, pInterface->Pipes[p].PipeFlags));

					AddEndpointInfo(pInterface->Pipes[p].PipeHandle,
						pInterface->Pipes[p].EndpointAddress);
				}
			}
		}
		break;
	case URB_FUNCTION_ABORT_PIPE:
		{
			struct _URB_PIPE_REQUEST   *pAbortPipe = (struct _URB_PIPE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_ABORT_PIPE:\n"));
			if(pAbortPipe->Hdr.Length < sizeof(struct _URB_PIPE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pAbortPipe->Hdr.Length, sizeof(struct _URB_PIPE_REQUEST)));

			if(!bReturnedFromHCD)
				DumpPipeHandle("  PipeHandle",pAbortPipe->PipeHandle);
		}
		break;
	case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
		{
			struct _URB_FRAME_LENGTH_CONTROL *pFrameLengthControl = (struct _URB_FRAME_LENGTH_CONTROL *) pUrb;

			KdPrint(("-- URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:\n"));
			if(pFrameLengthControl->Hdr.Length < sizeof(struct _URB_FRAME_LENGTH_CONTROL))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFrameLengthControl->Hdr.Length, sizeof(struct _URB_FRAME_LENGTH_CONTROL)));

			KdPrint(("  (no parameters)\n"));
		}
		break;
	case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
		{
			struct _URB_FRAME_LENGTH_CONTROL *pFrameLengthControl = (struct _URB_FRAME_LENGTH_CONTROL *) pUrb;

			KdPrint(("-- URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:\n"));
			if(pFrameLengthControl->Hdr.Length < sizeof(struct _URB_FRAME_LENGTH_CONTROL))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFrameLengthControl->Hdr.Length, sizeof(struct _URB_FRAME_LENGTH_CONTROL)));

			KdPrint(("  (no parameters)\n"));
		}
		break;
	case URB_FUNCTION_GET_FRAME_LENGTH:
		{
			struct _URB_GET_FRAME_LENGTH   *pGetFrameLength = (struct _URB_GET_FRAME_LENGTH *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_FRAME_LENGTH:\n"));
			if(pGetFrameLength->Hdr.Length < sizeof(struct _URB_GET_FRAME_LENGTH))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetFrameLength->Hdr.Length, sizeof(struct _URB_GET_FRAME_LENGTH)));

			if(bReturnedFromHCD)
			{
				KdPrint(("  FrameLength = %08x\n", pGetFrameLength->FrameLength));
				KdPrint(("  FrameNumber = %08x\n", pGetFrameLength->FrameNumber));
			}
		}
		break;
	case URB_FUNCTION_SET_FRAME_LENGTH:
		{
			struct _URB_SET_FRAME_LENGTH   *pSetFrameLength = (struct _URB_SET_FRAME_LENGTH *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FRAME_LENGTH:\n"));
			if(pSetFrameLength->Hdr.Length < sizeof(struct _URB_SET_FRAME_LENGTH))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFrameLength->Hdr.Length, sizeof(struct _URB_SET_FRAME_LENGTH)));

			if(!bReturnedFromHCD)
				KdPrint(("  FrameLengthDelta = %08x\n", pSetFrameLength->FrameLengthDelta));
		}
		break;
	case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
		{
			struct _URB_GET_CURRENT_FRAME_NUMBER   *pGetCurrentFrameNumber = (struct _URB_GET_CURRENT_FRAME_NUMBER *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:\n"));
			if(pGetCurrentFrameNumber->Hdr.Length < sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetCurrentFrameNumber->Hdr.Length, sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER)));

			if(bReturnedFromHCD)
				KdPrint(("  FrameNumber = %08x\n", pGetCurrentFrameNumber->FrameNumber));
		}
		break;
	case URB_FUNCTION_CONTROL_TRANSFER:
		{
			struct _URB_CONTROL_TRANSFER   *pControlTransfer = (struct _URB_CONTROL_TRANSFER *) pUrb;

			KdPrint(("-- URB_FUNCTION_CONTROL_TRANSFER:\n"));
			if(pControlTransfer->Hdr.Length < sizeof(struct _URB_CONTROL_TRANSFER))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pControlTransfer->Hdr.Length, sizeof(struct _URB_CONTROL_TRANSFER)));

			BOOLEAN bReadFromDevice = (BOOLEAN)(pControlTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle("  PipeHandle          ",pControlTransfer->PipeHandle);
			KdPrint(("  TransferFlags        = %08x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pControlTransfer->TransferFlags,
				bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
				pControlTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~"));
			DumpTransferBuffer((PUCHAR)pControlTransfer->TransferBuffer, pControlTransfer->TransferBufferMDL, pControlTransfer->TransferBufferLength, TRUE);
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer((PUCHAR)pControlTransfer->TransferBuffer, pControlTransfer->TransferBufferMDL, pControlTransfer->TransferBufferLength, FALSE);
			}

			KdPrint(("  UrbLink              = %08x\n", pControlTransfer->UrbLink));
			KdPrint(("  SetupPacket          :"));

			for(int b=0; b<sizeof(pControlTransfer->SetupPacket); b++)
				KdPrint((" %02x", pControlTransfer->SetupPacket[b]));
			KdPrint(("\n"));
			if(pControlTransfer->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pControlTransfer->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
		{
			struct _URB_BULK_OR_INTERRUPT_TRANSFER *pBulkOrInterruptTransfer = (struct _URB_BULK_OR_INTERRUPT_TRANSFER *) pUrb;

			KdPrint(("-- URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:\n"));
			if(pBulkOrInterruptTransfer->Hdr.Length < sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER ))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pBulkOrInterruptTransfer->Hdr.Length, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER)));

			BOOLEAN bReadFromDevice = (BOOLEAN)(pBulkOrInterruptTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle("  PipeHandle          ",pBulkOrInterruptTransfer->PipeHandle);
			KdPrint(("  TransferFlags        = %08x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pBulkOrInterruptTransfer->TransferFlags,
				bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
				pBulkOrInterruptTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~"));
			DumpTransferBuffer((PUCHAR)pBulkOrInterruptTransfer->TransferBuffer, pBulkOrInterruptTransfer->TransferBufferMDL, pBulkOrInterruptTransfer->TransferBufferLength, TRUE);
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer((PUCHAR)pBulkOrInterruptTransfer->TransferBuffer, pBulkOrInterruptTransfer->TransferBufferMDL, pBulkOrInterruptTransfer->TransferBufferLength, FALSE);
			}

			KdPrint(("  UrbLink              = %08x\n", pBulkOrInterruptTransfer->UrbLink));
			if(pBulkOrInterruptTransfer->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pBulkOrInterruptTransfer->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_ISOCH_TRANSFER:
		{
			struct _URB_ISOCH_TRANSFER *pIsochTransfer = (struct _URB_ISOCH_TRANSFER *) pUrb;

			KdPrint(("-- URB_FUNCTION_ISOCH_TRANSFER:\n"));
			if(pIsochTransfer->Hdr.Length < sizeof(struct _URB_ISOCH_TRANSFER ))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pIsochTransfer->Hdr.Length, sizeof(struct _URB_ISOCH_TRANSFER)));

			BOOLEAN bReadFromDevice = (BOOLEAN)(pIsochTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle("  PipeHandle          ",pIsochTransfer->PipeHandle);
			KdPrint(("  TransferFlags        = %08x (%s, %sUSBD_SHORT_TRANSFER_OK%sn", pIsochTransfer->TransferFlags,
				bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
				pIsochTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~",
				pIsochTransfer->TransferFlags & USBD_START_ISO_TRANSFER_ASAP ? ", USBD_START_ISO_TRANSFER_ASAP" : ""));
			DumpTransferBuffer((PUCHAR)pIsochTransfer->TransferBuffer, pIsochTransfer->TransferBufferMDL, pIsochTransfer->TransferBufferLength, TRUE);
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer((PUCHAR)pIsochTransfer->TransferBuffer, pIsochTransfer->TransferBufferMDL, pIsochTransfer->TransferBufferLength, FALSE);
			}

			KdPrint(("  StartFrame           = %08x\n", pIsochTransfer->StartFrame));
			KdPrint(("  NumberOfPackets      = %08x\n", pIsochTransfer->NumberOfPackets));
			if(bReturnedFromHCD)
				KdPrint(("  ErrorCount           = %08x\n", pIsochTransfer->ErrorCount));
			for(ULONG p=0; p < pIsochTransfer->NumberOfPackets; p++)
			{
				KdPrint(("  IsoPacket[%d].Offset = %08x\n", pIsochTransfer->IsoPacket[p].Offset));
				KdPrint(("  IsoPacket[%d].Length = %08x\n", pIsochTransfer->IsoPacket[p].Length));
				if(bReturnedFromHCD)
					KdPrint(("  IsoPacket[%d].Status = %08x\n", pIsochTransfer->IsoPacket[p].Status));
			}
			KdPrint(("  UrbLink              = %08x\n", pIsochTransfer->UrbLink));
			if(pIsochTransfer->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pIsochTransfer->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_RESET_PIPE:
		{
			struct _URB_PIPE_REQUEST   *pResetPipe = (struct _URB_PIPE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_RESET_PIPE:\n"));
			if(pResetPipe->Hdr.Length < sizeof(struct _URB_PIPE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pResetPipe->Hdr.Length, sizeof(struct _URB_PIPE_REQUEST)));

			if(!bReturnedFromHCD)
				DumpPipeHandle("  PipeHandle",pResetPipe->PipeHandle);
		}
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromDevice = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:\n"));
			if(pGetDescriptorFromDevice->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromDevice->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pGetDescriptorFromDevice, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromEndpoint = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:\n"));
			if(pGetDescriptorFromEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pGetDescriptorFromEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromInterface = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:\n"));
			if(pGetDescriptorFromInterface->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromInterface->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pGetDescriptorFromInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToDevice = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:\n"));
			if(pSetDescriptorToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pSetDescriptorToDevice, FALSE, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToEndpoint = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:\n"));
			if(pSetDescriptorToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pSetDescriptorToEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToInterface = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:\n"));
			if(pSetDescriptorToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)));
			DumpDescriptorRequest(pSetDescriptorToInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToDevice = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_DEVICE:\n"));
			if(pSetFeatureToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToDevice, TRUE, bReturnedFromHCD);
 
		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToInterface = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_INTERFACE:\n"));
			if(pSetFeatureToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToEndpoint = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:\n"));
			if(pSetFeatureToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_SET_FEATURE_TO_OTHER:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToOther = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_SET_FEATURE_TO_OTHER:\n"));
			if(pSetFeatureToOther->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToOther->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pSetFeatureToOther, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToDevice = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:\n"));
			if(pClearFeatureToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToDevice, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToInterface = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:\n"));
			if(pClearFeatureToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToInterface, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToEndpoint = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:\n"));
			if(pClearFeatureToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToEndpoint, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToOther = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:\n"));
			if(pClearFeatureToOther->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToOther->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST)));
			DumpFeatureRequest(pClearFeatureToOther, TRUE, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromDevice = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_DEVICE:\n"));
			if(pGetStatusFromDevice->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromDevice->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromDevice, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromInterface = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_INTERFACE:\n"));
			if(pGetStatusFromInterface->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromInterface->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromInterface, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromEndpoint = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:\n"));
			if(pGetStatusFromEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromEndpoint, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_GET_STATUS_FROM_OTHER:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromOther = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_STATUS_FROM_OTHER:\n"));
			if(pGetStatusFromOther->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromOther->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST)));
			DumpGetStatusRequest(pGetStatusFromOther, bReturnedFromHCD);

		}
		break;
	case URB_FUNCTION_VENDOR_DEVICE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorDevice = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_DEVICE:\n"));
			if(pFunctionVendorDevice->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorDevice->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorDevice, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_VENDOR_INTERFACE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorInterface = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_INTERFACE:\n"));
			if(pFunctionVendorInterface->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorInterface->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorInterface, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_VENDOR_ENDPOINT:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorEndpoint = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_ENDPOINT:\n"));
			if(pFunctionVendorEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorEndpoint, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_VENDOR_OTHER:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorOther = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_VENDOR_OTHER:\n"));
			if(pFunctionVendorOther->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorOther->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionVendorOther, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_DEVICE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassDevice = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_DEVICE:\n"));
			if(pFunctionClassDevice->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassDevice->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassDevice, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_INTERFACE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassInterface = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_INTERFACE:\n"));
			if(pFunctionClassInterface->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassInterface->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassInterface, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_ENDPOINT:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassEndpoint = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_ENDPOINT:\n"));
			if(pFunctionClassEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassEndpoint, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_CLASS_OTHER:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassOther = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_CLASS_OTHER:\n"));
			if(pFunctionClassOther->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassOther->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST)));

			DumpVendorOrClassRequest(pFunctionClassOther, bReturnedFromHCD);
		}
		break;
	case URB_FUNCTION_GET_CONFIGURATION:
		{
			struct _URB_CONTROL_GET_CONFIGURATION_REQUEST *pGetConfiguration = (struct _URB_CONTROL_GET_CONFIGURATION_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_CONFIGURATION:\n"));
			if(pGetConfiguration->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetConfiguration->Hdr.Length, sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST)));

			DumpTransferBuffer((PUCHAR)pGetConfiguration->TransferBuffer, pGetConfiguration->TransferBufferMDL, pGetConfiguration->TransferBufferLength, TRUE);
			if(pGetConfiguration->TransferBufferLength != 1)
				KdPrint(("  *** error - TransferBufferLength should be 1!\n"));

			if(bReturnedFromHCD)
			{
				DumpTransferBuffer((PUCHAR)pGetConfiguration->TransferBuffer, pGetConfiguration->TransferBufferMDL, pGetConfiguration->TransferBufferLength, FALSE);
			}

			KdPrint(("  UrbLink              = %08x\n", pGetConfiguration->UrbLink));
			if(pGetConfiguration->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pGetConfiguration->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;
	case URB_FUNCTION_GET_INTERFACE:
		{
			struct _URB_CONTROL_GET_INTERFACE_REQUEST *pGetInterface = (struct _URB_CONTROL_GET_INTERFACE_REQUEST *) pUrb;

			KdPrint(("-- URB_FUNCTION_GET_INTERFACE:\n"));
			if(pGetInterface->Hdr.Length < sizeof(struct _URB_CONTROL_GET_INTERFACE_REQUEST))
				KdPrint(("!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetInterface->Hdr.Length, sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST)));

			DumpTransferBuffer((PUCHAR)pGetInterface->TransferBuffer, pGetInterface->TransferBufferMDL, pGetInterface->TransferBufferLength, TRUE);
			if(pGetInterface->TransferBufferLength != 1)
				KdPrint(("  *** error - TransferBufferLength should be 1!\n"));

			if(bReturnedFromHCD)
			{
				DumpTransferBuffer((PUCHAR)pGetInterface->TransferBuffer, pGetInterface->TransferBufferMDL, pGetInterface->TransferBufferLength, FALSE);
			}

			KdPrint(("  Interface            = %02x\n", pGetInterface->UrbLink));
			KdPrint(("  UrbLink              = %08x\n", pGetInterface->UrbLink));
			if(pGetInterface->UrbLink)
			{
				KdPrint(("---> Linked URB:\n"));
				DumpURB(pGetInterface->UrbLink, bReturnedFromHCD);
				KdPrint(("---< Linked URB\n"));
			}
		}
		break;

	default:
		KdPrint(("******* non printable URB with function code 0x%04x ********\n", wFunction));
		break;
	}	// end of mega switch
//	ExQueueWorkItem(BottomHalf,CriticalWorkQueue);
}

NTSTATUS InternalIOCTLCompletion(IN PDEVICE_OBJECT fido, IN PIRP Irp, IN PVOID Context)
{
	KdPrint(("UsbSnoop - InternalIOCTLCompletion(%p) : fido=%p, Irp=%p, Context=%p\n",
		InternalIOCTLCompletion,fido,Irp,Context));
//	DumpIrp(Irp);

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

    if (Irp->PendingReturned) {
		KdPrint(("  IoMarkIrpPending\n"));
        IoMarkIrpPending( Irp );
    }

	ULONG uSequenceNumber = (ULONG)Context;
	ULONG dwControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
	if(IOCTL_INTERNAL_USB_SUBMIT_URB == dwControlCode)
	{
		KdPrint(("~<<<~ URB %d coming back ~<<<~\n", uSequenceNumber));
		PURB pUrb = (PURB)stack->Parameters.Others.Argument1;
		DumpURB(pUrb, TRUE);
	}
// TODO: check this line with the one in the downward irp handler! //	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return STATUS_SUCCESS;
}

NTSTATUS MyInternalIOCTLCompletion(IN PDEVICE_OBJECT fido, IN PIRP Irp, IN PVOID inContext)
{
	KdPrint(("UsbSnoop - MyInternalIOCTLCompletion(%p) : fido=%p, Irp=%p, Context=%p\n",
		MyInternalIOCTLCompletion,fido,Irp,inContext));

//	DumpIrp(Irp);

	PCONTEXT Context = (PCONTEXT)inContext;
//	DumpContext(Context);

	// restoring information.

	Context->Stack->CompletionRoutine = Context->CompletionRoutine;
	Context->Stack->Context           = Context->Context;
	Context->Stack->Control           = Context->Control;

	// dumping URB 
	KdPrint((" <<<  URB %d coming back  <<< \n",Context->uSequenceNumber));
	DumpURB(Context->pUrb, TRUE);


	// saving some field before freeing the structure
	PVOID OldContext = Context->Context;
	PIO_COMPLETION_ROUTINE OldCompletionRoutine = Context->CompletionRoutine;

	// freeing the allocated structure
	ExFreePool(Context);

	// calling the old CompletionRoutine, if there was one

	if (OldCompletionRoutine != NULL)
		return OldCompletionRoutine(fido,Irp,OldContext);

	return STATUS_SUCCESS;
}

NTSTATUS MyDispatchInternalIOCTL(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
	KdPrint(("UsbSnoop - MyDispatchInternalIOCTL(%p) : fdo=%p, Irp=%p\n",
		MyDispatchInternalIOCTL,fdo,Irp));
//	DumpDeviceObject(fdo);
//	DumpIrp(Irp);

	// we want to recover OriginalDriverObject which is stored in fido,
	// so we need to recover fido first, by the AttachedDevice field from FDO.

	PDEVICE_OBJECT fido = fdo->AttachedDevice;
//	KdPrint(("  fido = %p\n",fido));

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
//	KdPrint(("  OriginalDriverObject = %p\n",pdx->OriginalDriverObject));

	// try to print the URB 

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG dwControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
//	KdPrint(("  dwControlCode=%d\n",dwControlCode));
	if (dwControlCode == IOCTL_INTERNAL_USB_SUBMIT_URB)
	{
		ULONG uSequenceNumber = InterlockedIncrement((PLONG)&pdx->uSequenceNumber);
		KdPrint((" >>>  URB %d going down  >>> \n", uSequenceNumber));

		PURB pUrb = (PURB) stack->Parameters.Others.Argument1;
		DumpURB(pUrb,FALSE);

		// inspired from the macro code of IoSetCompletionRoutine
		// it just makes a big BSOD

		// ok. in fact, it worked, but that particular case,
		// the first parameter of the IoCompletionRoutine is NULL instead of being fido !!!

		// normalling, there should be a call to IoCopyCurrentIrpStackLocationToNext()
		// which might not be there. So, we are surely replacing other callbacks.

		// first, we saved every information we'll modify later

		PCONTEXT Context = (PCONTEXT)ExAllocatePool(PagedPool,sizeof(CONTEXT));
		if (Context != NULL)
		{
			Context->CompletionRoutine = stack->CompletionRoutine;
			Context->Context           = stack->Context;
			Context->Control           = stack->Control;
			Context->pUrb              = pUrb;
			Context->uSequenceNumber   = uSequenceNumber;
			Context->Stack             = stack;

//			KdPrint(("  Replacing %p/%p/%p by ",
//				stack->CompletionRoutine,stack->Context,stack->Control));
			stack->CompletionRoutine = MyInternalIOCTLCompletion;
			stack->Context = Context;
			stack->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

//			KdPrint(("%p/%p/%p\n",stack->CompletionRoutine,stack->Context,stack->Control));
		}
		else
			KdPrint(("  ExAllocatePool failed! Can't redirect CompletionRoutine\n"));
	}

	return pdx->OriginalDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL](fdo,Irp);
}

NTSTATUS DispatchInternalIOCTL(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

	KdPrint(("UsbSnoop - DispatchInternalIOCTL(%p) : fido=%p, Irp=%p\n",
		DispatchInternalIOCTL,fido,Irp));
//	DumpDeviceObject(fido);
//	DumpIrp(Irp);
	
	UCHAR type = stack->MinorFunction;
	PCHAR pFuncName = NULL;

	ULONG dwControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
	switch(dwControlCode)
	{
	case IOCTL_INTERNAL_USB_SUBMIT_URB:
		pFuncName = "IOCTL_INTERNAL_USB_SUBMIT_URB";
		break;

	case IOCTL_INTERNAL_USB_RESET_PORT:
		pFuncName = "IOCTL_INTERNAL_USB_RESET_PORT";
		break;

	case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
		pFuncName = "IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO";
		break;

	case IOCTL_INTERNAL_USB_GET_PORT_STATUS:
		pFuncName = "IOCTL_INTERNAL_USB_GET_PORT_STATUS";
		break;

	case IOCTL_INTERNAL_USB_ENABLE_PORT:
		pFuncName = "IOCTL_INTERNAL_USB_ENABLE_PORT";
		break;

	case IOCTL_INTERNAL_USB_GET_HUB_COUNT:
		pFuncName = "IOCTL_INTERNAL_USB_GET_HUB_COUNT";
		break;

	case IOCTL_INTERNAL_USB_CYCLE_PORT:
		pFuncName = "IOCTL_INTERNAL_USB_CYCLE_PORT";
		break;
// following IOCTL_XXX are not defined under Windows 98 DDK
/*
	case IOCTL_INTERNAL_USB_GET_HUB_NAME:
		pFuncName = "IOCTL_INTERNAL_USB_GET_HUB_NAME";
		break;

	case IOCTL_INTERNAL_USB_GET_BUS_INFO:
		pFuncName = "IOCTL_INTERNAL_USB_GET_BUS_INFO";
		break;

	case IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME:
		pFuncName = "IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME";
		break;
*/
	default:
		pFuncName = NULL;
		break;
	}
	
	if(pFuncName)
		KdPrint(("UsbSnoop - IRP_MJ_INTERNAL_DEVICE_CONTROL, %s\n", pFuncName));
	else
		KdPrint(("UsbSnoop - IRP_MJ_INTERNAL_DEVICE_CONTROL, unknown minor 0x%x\n", dwControlCode));

	NTSTATUS status;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);

	if(IOCTL_INTERNAL_USB_SUBMIT_URB == dwControlCode)
	{
		ULONG uSequenceNumber = InterlockedIncrement((PLONG)&pdx->uSequenceNumber);
		KdPrint(("~>>>~ URB %d going down ~>>>~\n", uSequenceNumber));
		PURB pUrb = (PURB)stack->Parameters.Others.Argument1;
		DumpURB(pUrb, FALSE);
		IoCopyCurrentIrpStackLocationToNext(Irp);
		IoSetCompletionRoutine(Irp, InternalIOCTLCompletion, (PVOID)uSequenceNumber, TRUE, TRUE, TRUE);


//		DumpIrp(Irp);
		status = IoCallDriver(pdx->LowerDeviceObject, Irp);

		// after IoCallDriver, Irp is no longer something usable
		//DumpIrp(Irp);
/// TODO - check next line with the one in the completion routine!
		IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	}
	else
	{
		IoSkipCurrentIrpStackLocation(Irp);
		status = IoCallDriver(pdx->LowerDeviceObject, Irp);
		IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	}
	
	return status;
}

/*
	DispatchPower - need a special code, since we have to call PoCallDriver()
	instead of IoCallDriver()
*/

NTSTATUS DispatchPower(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char* fcnname[] =
	{
		"IRP_MN_WAIT_WAKE",
		"IRP_MN_POWER_SEQUENCE",
		"IRP_MN_SET_POWER",
		"IRP_MN_QUERY_POWER",
	};
	
	if (fcn == IRP_MN_SET_POWER || fcn == IRP_MN_QUERY_POWER)
	{
		const char* sysstate[] =
		{
			"PowerSystemUnspecified",
			"PowerSystemWorking",
			"PowerSystemSleeping1",
			"PowerSystemSleeping2",
			"PowerSystemSleeping3",
			"PowerSystemHibernate",
			"PowerSystemShutdown",
			"PowerSystemMaximum",
		};
		
		const char* devstate[] =
		{
			"PowerDeviceUnspecified",
			"PowerDeviceD0",
			"PowerDeviceD1",
			"PowerDeviceD2",
			"PowerDeviceD3",
			"PowerDeviceMaximum",
		};
		
		ULONG context = stack->Parameters.Power.SystemContext;
		POWER_STATE_TYPE type = stack->Parameters.Power.Type;
		
		KdPrint(("UsbSnoop - IRP_MJ_POWER (%s), SystemContext %X", fcnname[fcn], context));
		if (type == SystemPowerState)
			KdPrint((", SystemPowerState = %s\n", sysstate[stack->Parameters.Power.State.SystemState]));
		else
			KdPrint((", DevicePowerState = %s\n", devstate[stack->Parameters.Power.State.DeviceState]));
	}
	else
		KdPrint(("UsbSnoop - IRP_MJ_POWER (%s)\n", fcnname[fcn]));
		
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PoStartNextPowerIrp(Irp);	// must be done while we own the IRP
	NTSTATUS status;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = PoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

NTSTATUS DispatchPnp(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char * MinorFunctionName = GetIrpPnpMinorFunctionName(fcn);
	if (MinorFunctionName != NULL)
		KdPrint(("UsbSnoop - DispatchPNP(%p) : IRP_MJ_PNP (%s)\n",
			DispatchPnp,MinorFunctionName));
	else
		KdPrint(("UsbSnoop - DispatchPNP(%p) : IRP_MJ_PNP (0x%x)\n",
			DispatchPnp,fcn));
	
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	
	if (fcn == IRP_MN_REMOVE_DEVICE)
	{
		IoReleaseRemoveLockAndWait(&pdx->RemoveLock, Irp);
		RemoveDevice(fido);
	}
	else
		IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	
	return status;
}

///////////////////////////////////////////////////////////////////////////////

NTSTATUS DispatchWmi(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{							// DispatchWmi
#if DBG
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	static char* fcnname[] = {
		"IRP_MN_QUERY_ALL_DATA",
		"IRP_MN_QUERY_SINGLE_INSTANCE",
		"IRP_MN_CHANGE_SINGLE_INSTANCE",
		"IRP_MN_CHANGE_SINGLE_ITEM",
		"IRP_MN_ENABLE_EVENTS",
		"IRP_MN_DISABLE_EVENTS",
		"IRP_MN_ENABLE_COLLECTION",
		"IRP_MN_DISABLE_COLLECTION",
		"IRP_MN_REGINFO",
		"IRP_MN_EXECUTE_METHOD",
	};
	
	KdPrint(("UsbSnoop - IRP_MJ_SYSTEM_CONTROL (%s)\n", fcnname[fcn]));
#endif // DBG
	
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma PAGEDCODE

VOID RemoveDevice(IN PDEVICE_OBJECT fido)
{
	PAGED_CODE();
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;

	KdPrint(("UsbSnoop - RemoveDevice(%p) : fido = %p\n",RemoveDevice,fido));
	
	if (pdx->LowerDeviceObject)
	{
		// save our modified PDRIVER_OBJECT
		PDRIVER_OBJECT d = pdx->LowerDeviceObject->DriverObject;

		// restore the driver pointer in the PDO
		pdx->LowerDeviceObject->DriverObject = pdx->OriginalDriverObject;

		IoDetachDevice(pdx->LowerDeviceObject);

		// free our modified PDRIVER_OBJECT
		ExFreePool(d);
	}

	IoDeleteDevice(fido);
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE

extern "C" void __declspec(naked) __cdecl _chkesp()
{
	_asm je okay
	ASSERT(!"Stack pointer mismatch!");
okay:
	_asm ret
}
>>>>>>> 1.3
